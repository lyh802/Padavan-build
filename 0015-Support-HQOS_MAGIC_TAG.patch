From 834344b6d143ab83cf8ebefb617f0857bce3f73c Mon Sep 17 00:00:00 2001
From: lyh802 <lyh802@126.com>
Date: Tue, 20 Jun 2023 17:55:46 +0800
Subject: [PATCH 5/5] Support HQOS_MAGIC_TAG

---
 .../ethernet/mediatek/mtk_hnat/hnat_nf_hook.c | 34 +++++++++++--------
 .../ethernet/raeth/mtk_hnat/hnat_nf_hook.c    | 34 +++++++++++--------
 trunk/linux-4.4.x/net/8021q/vlan.c            |  8 +++++
 trunk/linux-4.4.x/net/core/dev.c              |  6 ++++
 4 files changed, 54 insertions(+), 28 deletions(-)

diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_nf_hook.c b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_nf_hook.c
index 353a2098..2db8109a 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_nf_hook.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_nf_hook.c
@@ -519,7 +519,8 @@ unsigned int do_hnat_ge_to_ext(struct sk_buff *skb, const char *func)
 
 	//if (qos_toggle && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 	if (IS_HQOS_MODE && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
-		skb = skb_unshare(skb, GFP_ATOMIC);
+		skb = skb_unshare(skb, GFP_ATOMIC);
+		//skb = skb_share_check(skb, GFP_ATOMIC);
 		if (!skb)
 			return NF_ACCEPT;
 
@@ -527,6 +528,7 @@ unsigned int do_hnat_ge_to_ext(struct sk_buff *skb, const char *func)
 			return NF_ACCEPT;
 
 		skb_pull_rcsum(skb, VLAN_HLEN);
+		//vlan_set_encap_proto(skb, (struct vlan_hdr *)skb->data);
 
 		memmove(skb->data - ETH_HLEN, skb->data - ETH_HLEN - VLAN_HLEN,
 			2 * ETH_ALEN);
@@ -1002,7 +1004,7 @@ mtk_hnat_br_nf_local_in(void *priv, struct sk_buff *skb,
 		veth = (struct vlan_ethhdr *)skb_mac_header(skb);
 
 		if (eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
-			skb_hnat_entry(skb) = ntohs(veth->h_vlan_TCI) & 0x3fff;
+			skb_hnat_entry(skb) = veth->h_vlan_TCI & 0x3fff;
 			skb_hnat_reason(skb) = HIT_BIND_FORCE_TO_CPU;
 		}
 	}
@@ -1336,6 +1338,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 	u32 qid = 0;
 	u32 port_id = 0;
 	int mape = 0;
+	u16 vlan1 = 1;
 
 	//FIXME:
 	ct = nf_ct_get(skb, &ctinfo);
@@ -1826,9 +1829,9 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 			entry.bfib1.vlan_layer = 1;
 
 			if (FROM_GE_LAN_GRP(skb))
-				entry.ipv4_hnapt.vlan1 = 1;
+				vlan1 = entry.ipv4_hnapt.vlan1 = 1;
 			else if (FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))
-				entry.ipv4_hnapt.vlan1 = 2;
+				vlan1 = entry.ipv4_hnapt.vlan1 = 2;
 		}
 
 		trace_printk("learn of lan or wan(iif=%x) --> %s(ext)\n",
@@ -1879,7 +1882,8 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				      ((mape_toggle && mape == 1) && !FROM_EXT(skb))) &&
 				      (!whnat)) {
 					entry.ipv4_hnapt.etype = htons(HQOS_MAGIC_TAG);
-					entry.ipv4_hnapt.vlan1 = skb_hnat_entry(skb);
+					entry.ipv4_hnapt.vlan1 = ntohs(((vlan1 - 1) << 14) | skb_hnat_entry(skb));
+					entry.bfib1.vpm = 0;
 					entry.bfib1.vlan_layer = 1;
 				}
 			}
@@ -1926,7 +1930,8 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				    FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb)) &&
 				    (!whnat)) {
 					entry.ipv6_5t_route.etype = htons(HQOS_MAGIC_TAG);
-					entry.ipv6_5t_route.vlan1 = skb_hnat_entry(skb);
+					entry.ipv6_5t_route.vlan1 = ntohs(((vlan1 - 1) << 14) | skb_hnat_entry(skb));
+					entry.bfib1.vpm = 0;
 					entry.bfib1.vlan_layer = 1;
 				}
 			}
@@ -1985,6 +1990,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 	struct foe_entry *entry;
 	struct ethhdr *eth;
 	struct hnat_bind_info_blk bfib1_tx;
+	u16 vlan1 = 1;
 
 	//FIXME:if (skb_hnat_alg(skb) || !is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb))
 	if (skb_hnat_alg(skb) || !is_hnat_info_filled(skb) ||
@@ -2124,9 +2130,9 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 				bfib1_tx.vlan_layer = 1;
 
 				if (FROM_GE_LAN_GRP(skb))
-					entry->ipv4_hnapt.vlan1 = 1;
+					vlan1 = entry->ipv4_hnapt.vlan1 = 1;
 				else if (FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))
-					entry->ipv4_hnapt.vlan1 = 2;
+					vlan1 = entry->ipv4_hnapt.vlan1 = 2;
 			}
 
 			/*if (qos_toggle &&
@@ -2136,7 +2142,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 				bfib1_tx.vpm = 0;
 				bfib1_tx.vlan_layer = 1;
 				entry->ipv4_hnapt.etype = htons(HQOS_MAGIC_TAG);
-				entry->ipv4_hnapt.vlan1 = skb_hnat_entry(skb);
+				entry->ipv4_hnapt.vlan1 = ntohs(((vlan1 - 1) << 14) | skb_hnat_entry(skb));
 				entry->ipv4_hnapt.iblk2.fqos = 1;
 			}
 		}
@@ -2203,9 +2209,9 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 				bfib1_tx.vlan_layer = 1;
 
 				if (FROM_GE_LAN_GRP(skb))
-					entry->ipv6_5t_route.vlan1 = 1;
+					vlan1 = entry->ipv6_5t_route.vlan1 = 1;
 				else if (FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))
-					entry->ipv6_5t_route.vlan1 = 2;
+					vlan1 = entry->ipv6_5t_route.vlan1 = 2;
 			}
 
 			/*if (qos_toggle &&
@@ -2215,7 +2221,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 				bfib1_tx.vpm = 0;
 				bfib1_tx.vlan_layer = 1;
 				entry->ipv6_5t_route.etype = htons(HQOS_MAGIC_TAG);
-				entry->ipv6_5t_route.vlan1 = skb_hnat_entry(skb);
+				entry->ipv6_5t_route.vlan1 = ntohs(((vlan1 - 1) << 14) | skb_hnat_entry(skb));
 				entry->ipv6_5t_route.iblk2.fqos = 1;
 			}
 		}
@@ -2928,7 +2934,7 @@ mtk_pong_hqos_handler(void *priv, struct sk_buff *skb,
 
 	//if (qos_toggle && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 	if (IS_HQOS_MODE && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
-		skb_hnat_entry(skb) = ntohs(veth->h_vlan_TCI) & 0x3fff;
+		skb_hnat_entry(skb) = veth->h_vlan_TCI & 0x3fff;
 		skb_hnat_reason(skb) = HIT_BIND_FORCE_TO_CPU;
 	}
 
@@ -3140,7 +3146,7 @@ int mtk_hqos_ptype_cb(struct sk_buff *skb, struct net_device *dev,
 {
 	struct vlan_ethhdr *veth = (struct vlan_ethhdr *)skb_mac_header(skb);
 
-	skb_hnat_entry(skb) = ntohs(veth->h_vlan_TCI) & 0x3fff;
+	skb_hnat_entry(skb) = veth->h_vlan_TCI & 0x3fff;
 	skb_hnat_reason(skb) = HIT_BIND_FORCE_TO_CPU;
 
 	if (do_hnat_ge_to_ext(skb, __func__) == -1)
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c
index 353a2098..2db8109a 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c
@@ -519,7 +519,8 @@ unsigned int do_hnat_ge_to_ext(struct sk_buff *skb, const char *func)
 
 	//if (qos_toggle && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 	if (IS_HQOS_MODE && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
-		skb = skb_unshare(skb, GFP_ATOMIC);
+		skb = skb_unshare(skb, GFP_ATOMIC);
+		//skb = skb_share_check(skb, GFP_ATOMIC);
 		if (!skb)
 			return NF_ACCEPT;
 
@@ -527,6 +528,7 @@ unsigned int do_hnat_ge_to_ext(struct sk_buff *skb, const char *func)
 			return NF_ACCEPT;
 
 		skb_pull_rcsum(skb, VLAN_HLEN);
+		//vlan_set_encap_proto(skb, (struct vlan_hdr *)skb->data);
 
 		memmove(skb->data - ETH_HLEN, skb->data - ETH_HLEN - VLAN_HLEN,
 			2 * ETH_ALEN);
@@ -1002,7 +1004,7 @@ mtk_hnat_br_nf_local_in(void *priv, struct sk_buff *skb,
 		veth = (struct vlan_ethhdr *)skb_mac_header(skb);
 
 		if (eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
-			skb_hnat_entry(skb) = ntohs(veth->h_vlan_TCI) & 0x3fff;
+			skb_hnat_entry(skb) = veth->h_vlan_TCI & 0x3fff;
 			skb_hnat_reason(skb) = HIT_BIND_FORCE_TO_CPU;
 		}
 	}
@@ -1336,6 +1338,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 	u32 qid = 0;
 	u32 port_id = 0;
 	int mape = 0;
+	u16 vlan1 = 1;
 
 	//FIXME:
 	ct = nf_ct_get(skb, &ctinfo);
@@ -1826,9 +1829,9 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 			entry.bfib1.vlan_layer = 1;
 
 			if (FROM_GE_LAN_GRP(skb))
-				entry.ipv4_hnapt.vlan1 = 1;
+				vlan1 = entry.ipv4_hnapt.vlan1 = 1;
 			else if (FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))
-				entry.ipv4_hnapt.vlan1 = 2;
+				vlan1 = entry.ipv4_hnapt.vlan1 = 2;
 		}
 
 		trace_printk("learn of lan or wan(iif=%x) --> %s(ext)\n",
@@ -1879,7 +1882,8 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				      ((mape_toggle && mape == 1) && !FROM_EXT(skb))) &&
 				      (!whnat)) {
 					entry.ipv4_hnapt.etype = htons(HQOS_MAGIC_TAG);
-					entry.ipv4_hnapt.vlan1 = skb_hnat_entry(skb);
+					entry.ipv4_hnapt.vlan1 = ntohs(((vlan1 - 1) << 14) | skb_hnat_entry(skb));
+					entry.bfib1.vpm = 0;
 					entry.bfib1.vlan_layer = 1;
 				}
 			}
@@ -1926,7 +1930,8 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				    FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb)) &&
 				    (!whnat)) {
 					entry.ipv6_5t_route.etype = htons(HQOS_MAGIC_TAG);
-					entry.ipv6_5t_route.vlan1 = skb_hnat_entry(skb);
+					entry.ipv6_5t_route.vlan1 = ntohs(((vlan1 - 1) << 14) | skb_hnat_entry(skb));
+					entry.bfib1.vpm = 0;
 					entry.bfib1.vlan_layer = 1;
 				}
 			}
@@ -1985,6 +1990,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 	struct foe_entry *entry;
 	struct ethhdr *eth;
 	struct hnat_bind_info_blk bfib1_tx;
+	u16 vlan1 = 1;
 
 	//FIXME:if (skb_hnat_alg(skb) || !is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb))
 	if (skb_hnat_alg(skb) || !is_hnat_info_filled(skb) ||
@@ -2124,9 +2130,9 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 				bfib1_tx.vlan_layer = 1;
 
 				if (FROM_GE_LAN_GRP(skb))
-					entry->ipv4_hnapt.vlan1 = 1;
+					vlan1 = entry->ipv4_hnapt.vlan1 = 1;
 				else if (FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))
-					entry->ipv4_hnapt.vlan1 = 2;
+					vlan1 = entry->ipv4_hnapt.vlan1 = 2;
 			}
 
 			/*if (qos_toggle &&
@@ -2136,7 +2142,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 				bfib1_tx.vpm = 0;
 				bfib1_tx.vlan_layer = 1;
 				entry->ipv4_hnapt.etype = htons(HQOS_MAGIC_TAG);
-				entry->ipv4_hnapt.vlan1 = skb_hnat_entry(skb);
+				entry->ipv4_hnapt.vlan1 = ntohs(((vlan1 - 1) << 14) | skb_hnat_entry(skb));
 				entry->ipv4_hnapt.iblk2.fqos = 1;
 			}
 		}
@@ -2203,9 +2209,9 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 				bfib1_tx.vlan_layer = 1;
 
 				if (FROM_GE_LAN_GRP(skb))
-					entry->ipv6_5t_route.vlan1 = 1;
+					vlan1 = entry->ipv6_5t_route.vlan1 = 1;
 				else if (FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))
-					entry->ipv6_5t_route.vlan1 = 2;
+					vlan1 = entry->ipv6_5t_route.vlan1 = 2;
 			}
 
 			/*if (qos_toggle &&
@@ -2215,7 +2221,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 				bfib1_tx.vpm = 0;
 				bfib1_tx.vlan_layer = 1;
 				entry->ipv6_5t_route.etype = htons(HQOS_MAGIC_TAG);
-				entry->ipv6_5t_route.vlan1 = skb_hnat_entry(skb);
+				entry->ipv6_5t_route.vlan1 = ntohs(((vlan1 - 1) << 14) | skb_hnat_entry(skb));
 				entry->ipv6_5t_route.iblk2.fqos = 1;
 			}
 		}
@@ -2928,7 +2934,7 @@ mtk_pong_hqos_handler(void *priv, struct sk_buff *skb,
 
 	//if (qos_toggle && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 	if (IS_HQOS_MODE && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
-		skb_hnat_entry(skb) = ntohs(veth->h_vlan_TCI) & 0x3fff;
+		skb_hnat_entry(skb) = veth->h_vlan_TCI & 0x3fff;
 		skb_hnat_reason(skb) = HIT_BIND_FORCE_TO_CPU;
 	}
 
@@ -3140,7 +3146,7 @@ int mtk_hqos_ptype_cb(struct sk_buff *skb, struct net_device *dev,
 {
 	struct vlan_ethhdr *veth = (struct vlan_ethhdr *)skb_mac_header(skb);
 
-	skb_hnat_entry(skb) = ntohs(veth->h_vlan_TCI) & 0x3fff;
+	skb_hnat_entry(skb) = veth->h_vlan_TCI & 0x3fff;
 	skb_hnat_reason(skb) = HIT_BIND_FORCE_TO_CPU;
 
 	if (do_hnat_ge_to_ext(skb, __func__) == -1)
diff --git a/trunk/linux-4.4.x/net/8021q/vlan.c b/trunk/linux-4.4.x/net/8021q/vlan.c
index e2713b07..c4a10786 100644
--- a/trunk/linux-4.4.x/net/8021q/vlan.c
+++ b/trunk/linux-4.4.x/net/8021q/vlan.c
@@ -703,6 +703,14 @@ static struct packet_offload vlan_packet_offloads[] __read_mostly = {
 			.gro_complete = vlan_gro_complete,
 		},
 	},
+	{
+		.type = 0x5678,
+		.priority = 10,
+		.callbacks = {
+			.gro_receive = vlan_gro_receive,
+			.gro_complete = vlan_gro_complete,
+		},
+	},
 };
 
 static int __net_init vlan_init_net(struct net *net)
diff --git a/trunk/linux-4.4.x/net/core/dev.c b/trunk/linux-4.4.x/net/core/dev.c
index 221c4207..52ad0cac 100644
--- a/trunk/linux-4.4.x/net/core/dev.c
+++ b/trunk/linux-4.4.x/net/core/dev.c
@@ -3891,6 +3891,7 @@ static bool skb_pfmemalloc_protocol(struct sk_buff *skb)
 	case htons(ETH_P_IPV6):
 	case htons(ETH_P_8021Q):
 	case htons(ETH_P_8021AD):
+	case 0x5678:
 		return true;
 	default:
 		return false;
@@ -3938,6 +3939,11 @@ static int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)
 
 	pt_prev = NULL;
 
+	if (skb->protocol == 0x5678) {
+		// VLAN1
+		__vlan_hwaccel_put_tag(skb, cpu_to_be16(ETH_P_8021Q), 1);
+	}
+
 another_round:
 	skb->skb_iif = skb->dev->ifindex;
 
-- 
2.32.0.windows.2

