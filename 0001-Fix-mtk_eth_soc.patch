From 583c663938a11f56f261243653bedb19ca69d76c Mon Sep 17 00:00:00 2001
From: lyh802 <lyh802@126.com>
Date: Sun, 18 Jun 2023 18:43:02 +0800
Subject: [PATCH] Fix mtk_eth_soc

---
 .../drivers/net/ethernet/mediatek/Makefile    |   4 +
 .../net/ethernet/mediatek/mtk_eth_dbg.c       |  24 ++-
 .../net/ethernet/mediatek/mtk_eth_soc.c       | 145 +++++++++---------
 .../net/ethernet/mediatek/mtk_eth_soc.h       |  11 +-
 4 files changed, 105 insertions(+), 79 deletions(-)

diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/Makefile b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/Makefile
index 6cf0a24..84c7be6 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/Makefile
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/Makefile
@@ -6,3 +6,7 @@ obj-$(CONFIG_NET_MEDIATEK_SOC)			+= mtk_eth_soc.o mtk_sgmii.o \
 						   mtk_eth_path.o
 obj-$(CONFIG_NET_MEDIATEK_DBG)			+= mtk_eth_dbg.o
 obj-$(CONFIG_NET_MEDIATEK_HNAT)                 += mtk_hnat/
+
+ifeq ($(CONFIG_ASUS_EXT),y)
+EXTRA_CFLAGS += -DASUS_EXT
+endif
\ No newline at end of file
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_dbg.c b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_dbg.c
index a745edd..c19116a 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_dbg.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_dbg.c
@@ -32,19 +32,27 @@ struct mtk_eth *g_eth;
 
 void mt7530_mdio_w32(struct mtk_eth *eth, u32 reg, u32 val)
 {
+	mutex_lock(&eth->mii_bus->mdio_lock);
+
 	_mtk_mdio_write(eth, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
 	_mtk_mdio_write(eth, 0x1f, (reg >> 2) & 0xf,  val & 0xffff);
 	_mtk_mdio_write(eth, 0x1f, 0x10, val >> 16);
+
+	mutex_unlock(&eth->mii_bus->mdio_lock);
 }
 
 u32 mt7530_mdio_r32(struct mtk_eth *eth, u32 reg)
 {
 	u16 high, low;
 
+	mutex_lock(&eth->mii_bus->mdio_lock);
+
 	_mtk_mdio_write(eth, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
 	low = _mtk_mdio_read(eth, 0x1f, (reg >> 2) & 0xf);
 	high = _mtk_mdio_read(eth, 0x1f, 0x10);
 
+	mutex_unlock(&eth->mii_bus->mdio_lock);
+
 	return (high << 16) | (low & 0xffff);
 }
 
@@ -74,8 +82,9 @@ static int mtketh_debug_show(struct seq_file *m, void *private)
 		mac = eth->mac[i];
 
 		while (j < 30) {
+			mutex_lock(&eth->mii_bus->mdio_lock);
 			d =  _mtk_mdio_read(eth, mac->phy_dev->addr, j);
-
+			mutex_unlock(&eth->mii_bus->mdio_lock);
 			seq_printf(m, "phy=%d, reg=0x%08x, data=0x%08x\n",
 				   mac->phy_dev->addr, j, d);
 			j++;
@@ -279,11 +288,13 @@ static ssize_t mtketh_debugfs_write(struct file *file, const char __user *ptr,
 	pr_info("%s:phy=%d, reg=0x%x, val=0x%x\n", __func__,
 		phy, reg, value);
 
+	mutex_lock(&eth->mii_bus->mdio_lock);
 	_mtk_mdio_write(eth, phy,  reg, value);
 
 	pr_info("%s:phy=%d, reg=0x%x, val=0x%x confirm..\n", __func__,
 		phy, reg, _mtk_mdio_read(eth, phy, reg));
 
+	mutex_unlock(&eth->mii_bus->mdio_lock);
 	return len;
 }
 
@@ -356,9 +367,12 @@ void mii_mgr_read_combine(struct mtk_eth *eth, u32 phy_addr, u32 phy_register,
 		*read_data = mt7530_mdio_r32(eth, phy_register);
 
 	else
-		*read_data = _mtk_mdio_read(eth, phy_addr, phy_register);
+		*read_data = mdiobus_read_nested(eth->mii_bus, phy_addr,
+						 phy_register);
 }
-
+#if defined(ASUS_EXT)
+EXPORT_SYMBOL(mii_mgr_read_combine);
+#endif
 void mii_mgr_write_combine(struct mtk_eth *eth, u32 phy_addr, u32 phy_register,
 			   u32 write_data)
 {
@@ -366,7 +380,8 @@ void mii_mgr_write_combine(struct mtk_eth *eth, u32 phy_addr, u32 phy_register,
 		mt7530_mdio_w32(eth, phy_register, write_data);
 
 	else
-		_mtk_mdio_write(eth, phy_addr, phy_register, write_data);
+		mdiobus_write_nested(eth->mii_bus, phy_addr, phy_register,
+				     write_data);
 }
 
 static void mii_mgr_read_cl45(struct mtk_eth *eth, u32 port, u32 devad, u32 reg, u32 *data)
@@ -442,7 +457,6 @@ int mtk_do_priv_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 
 		return 0;
 	default:
-		pr_info("%s ioctl %d is not supported", __func__, cmd);
 		break;
 	}
 
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_soc.c
index b0f8975..1c3f410 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -367,38 +367,6 @@ static int mtk_phy_connect_node(struct mtk_eth *eth, struct mtk_mac *mac,
 	return 0;
 }
 
-static void mtk_phy_print_status(struct net_device *dev)
-{
-	phy_print_status(dev->phydev);
-}
-
-static int mtk_phy_link_connect_node(struct mtk_eth *eth, struct mtk_mac *mac,
-				                                     struct device_node *phy_node)
-{
-	struct phy_device *phydev;
-	int phy_mode;
-
-	phy_mode = of_get_phy_mode(phy_node);
-	if (phy_mode < 0) {
-		dev_err(eth->dev, "incorrect phy-mode %d\n", phy_mode);
-		return -EINVAL;
-	}
-
-	phydev = of_phy_connect(eth->netdev[mac->id], phy_node,
-				mtk_phy_print_status, 0, phy_mode);
-	if (!phydev) {
-		dev_err(eth->dev, "could not connect to PHY\n");
-		return -ENODEV;
-	}
-
-	dev_info(eth->dev,
-		 "connected mac %d to PHY at %s [uid=%08x, driver=%s]\n",
-		 mac->id, dev_name(&phydev->dev), phydev->phy_id,
-		 phydev->drv->name);
-
-	return 0;
-}
-
 static int mtk_phy_connect(struct net_device *dev)
 {
 	struct mtk_mac *mac = netdev_priv(dev);
@@ -780,6 +748,10 @@ static int mtk_tx_map(struct sk_buff *skb, struct net_device *dev,
 	if (skb->ip_summed == CHECKSUM_PARTIAL)
 		txd4 |= TX_DMA_CHKSUM;
 
+	/* VLAN header offload */
+	if (skb_vlan_tag_present(skb))
+		txd4 |= TX_DMA_INS_VLAN | skb_vlan_tag_get(skb);
+
 #if defined(CONFIG_NET_MEDIATEK_HW_QOS)
 	qid = skb->mark & (MTK_QDMA_TX_MASK);
 #else
@@ -1062,12 +1034,9 @@ static int mtk_poll_rx(struct napi_struct *napi, int budget,
 			break;
 
 		/* find out which mac the packet come from. values start at 1 */
-#if defined(CONFIG_NET_DSA)
-		mac = (trxd.rxd4 >> 22) & 0x1;
-		mac = (mac + 1) % 2;
-#else
 		mac = (trxd.rxd4 >> RX_DMA_FPORT_SHIFT) &
 			RX_DMA_FPORT_MASK;
+
 		/* From QDMA(5). This is a external interface case of HWNAT.
 		 * When the incoming frame comes from an external interface
 		 * rather than GMAC1/GMAC2, HWNAT driver sends the original
@@ -1075,11 +1044,19 @@ static int mtk_poll_rx(struct napi_struct *napi, int budget,
 		 * frame learning. After learning, PPE transmit the
 		 * original frame back to PPD again to run SW NAT path.
 		 */
+#if defined(CONFIG_NET_DSA_MT7530)
+		/* In dsa case, when PSE(before mt7622) receives frame with
+		 * switch special tag, rxd4[22] will be set to 1, and FPORT
+		 * will be set to switch ingress port. The real PSE ingress
+		 * port of this kind of traffic is GMAC1 actually.
+		 */
+		if (mac == 5 || (trxd.rxd4 & BIT(22)))
+#else
 		if (mac == 5)
+#endif
 			mac = 0;
 		else
 			mac--;
-#endif
 		if (unlikely(mac < 0 || mac >= MTK_MAC_COUNT ||
 			     !eth->netdev[mac]))
 			goto release_desc;
@@ -1126,9 +1103,20 @@ static int mtk_poll_rx(struct napi_struct *napi, int budget,
 		skb->protocol = eth_type_trans(skb, netdev);
 
 		if (netdev->features & NETIF_F_HW_VLAN_CTAG_RX &&
-		    RX_DMA_VID(trxd.rxd3))
-			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
-					       RX_DMA_VID(trxd.rxd3));
+		    (trxd.rxd2 & RX_DMA_VTAG)) {
+			__vlan_hwaccel_put_tag(skb,
+					       htons(RX_DMA_VPID(trxd.rxd3)),
+					       RX_DMA_TCI(trxd.rxd3));
+
+			/* If netdev is attached to dsa switch with special
+			 * tag protocol on VLAN field, the special tag can
+			 * be offload by RX HW VLAN offload. Disable
+			 * VLAN_TAG_PRESENT to avoid unexpected 8021d
+			 * handler before packet enter dsa framework.
+			 */
+			if (netdev_uses_dsa(netdev))
+				skb->vlan_tci &= ~VLAN_TAG_PRESENT;
+		}
 
 #if defined(CONFIG_NET_MEDIATEK_HNAT) || defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
 		*(u32 *)(skb->head) = trxd.rxd4;
@@ -1837,6 +1825,7 @@ static void mtk_dma_free(struct mtk_eth *eth)
 	}
 
 	kfree(eth->scratch_head);
+	eth->scratch_head = NULL;
 }
 
 static void mtk_tx_timeout(struct net_device *dev)
@@ -1883,8 +1872,8 @@ static irqreturn_t mtk_handle_irq_rx(int irq, void *_eth)
 	struct mtk_eth *eth = _eth;
 
 	if (likely(napi_schedule_prep(&eth->rx_napi))) {
-		__napi_schedule(&eth->rx_napi);
 		mtk_rx_irq_disable(eth, MTK_RX_DONE_INT);
+		__napi_schedule(&eth->rx_napi);
 	}
 
 	return IRQ_HANDLED;
@@ -1895,8 +1884,8 @@ static irqreturn_t mtk_handle_irq_tx(int irq, void *_eth)
 	struct mtk_eth *eth = _eth;
 
 	if (likely(napi_schedule_prep(&eth->tx_napi))) {
-		__napi_schedule(&eth->tx_napi);
 		mtk_tx_irq_disable(eth, MTK_TX_DONE_INT);
+		__napi_schedule(&eth->tx_napi);
 	}
 
 	return IRQ_HANDLED;
@@ -1941,20 +1930,24 @@ static int mtk_start_dma(struct mtk_eth *eth)
 	return 0;
 }
 
-static void mtk_gdma_config(struct mtk_eth *eth, u32 config)
+static void mtk_gdma_igr_ctrl(struct mtk_eth *eth, u32 gdma, u32 action)
 {
-	int i;
+	u32 val = mtk_r32(eth, MTK_GDMA_FWD_CFG(gdma));
 
-	for (i = 0; i < 2; i++) {
-		u32 val = mtk_r32(eth, MTK_GDMA_FWD_CFG(i));
+	/* default setup the forward port to send frame to PDMA */
+	val &= ~0xffff;
+	val |= action;
 
-		/* default setup the forward port to send frame to PDMA */
-		val &= ~0xffff;
+	mtk_w32(eth, val, MTK_GDMA_FWD_CFG(gdma));
+}
 
-		val |= config;
+static void mtk_gdma_config(struct mtk_eth *eth, u32 config)
+{
+	int i;
+
+	for (i = 0; i < 2; i++)
+		mtk_gdma_igr_ctrl(eth, i, config);
 
-		mtk_w32(eth, val, MTK_GDMA_FWD_CFG(i));
-	}
 	/*Reset and enable PSE*/
 	mtk_w32(eth, RST_GL_PSE, MTK_RST_GL);
 	mtk_w32(eth, 0, MTK_RST_GL);
@@ -1964,7 +1957,6 @@ static int mtk_open(struct net_device *dev)
 {
 	struct mtk_mac *mac = netdev_priv(dev);
 	struct mtk_eth *eth = mac->hw;
-	struct device_node *np;
 
 	/* we run 2 netdevs on the same dma ring so we only bring it up once */
 	if (!atomic_read(&eth->dma_refcnt)) {
@@ -1973,7 +1965,6 @@ static int mtk_open(struct net_device *dev)
 		if (err)
 			return err;
 
-		mtk_gdma_config(eth, MTK_GDMA_ICS_EN | MTK_GDMA_TCS_EN | MTK_GDMA_UCS_EN);
 
 		napi_enable(&eth->tx_napi);
 		napi_enable(&eth->rx_napi);
@@ -1982,16 +1973,25 @@ static int mtk_open(struct net_device *dev)
 	}
 	atomic_inc(&eth->dma_refcnt);
 
-	np = of_parse_phandle(mac->of_node, "phy-link-handle", 0);
-	if (np) {
-		if (dev->phydev)
-			phy_disconnect(dev->phydev);
-		mtk_phy_link_connect_node(eth, mac, np);
+	if (dev == eth->netdev[0] && netdev_uses_dsa(dev)) {
+		u32 val;
+
+		/* Indicates CDM to parse the MTK special tag from CPU
+		 * which only works for packets tagged with DSA_TAG_PROTO_MTK.
+		 */
+		val = mtk_r32(eth, MTK_GDMA_FWD_CFG(0));
+		mtk_w32(eth, val | MTK_GDMA_SPEC_TAG, MTK_GDMA_FWD_CFG(0));
+		val = mtk_r32(eth, MTK_CDMP_IG_CTRL);
+		mtk_w32(eth, val | MTK_CDMP_STAG_EN, MTK_CDMP_IG_CTRL);
+		val = mtk_r32(eth, MTK_CDMQ_IG_CTRL);
+		mtk_w32(eth, val | MTK_CDMQ_STAG_EN, MTK_CDMQ_IG_CTRL);
 	}
 
 	phy_start(dev->phydev);
 	netif_start_queue(dev);
 
+	mtk_gdma_igr_ctrl(eth, mac->id, MTK_GDMA_PDMA_ALL);
+
 	return 0;
 }
 
@@ -2023,6 +2023,8 @@ static int mtk_stop(struct net_device *dev)
 	struct mtk_mac *mac = netdev_priv(dev);
 	struct mtk_eth *eth = mac->hw;
 
+	mtk_gdma_igr_ctrl(eth, mac->id, MTK_GDMA_DROP_ALL);
+
 	netif_tx_disable(dev);
 	phy_stop(dev->phydev);
 
@@ -2030,7 +2032,6 @@ static int mtk_stop(struct net_device *dev)
 	if (!atomic_dec_and_test(&eth->dma_refcnt))
 		return 0;
 
-	mtk_gdma_config(eth, MTK_GDMA_DROP_ALL);
 
 	mtk_tx_irq_disable(eth, MTK_TX_DONE_INT);
 	mtk_rx_irq_disable(eth, MTK_RX_DONE_INT);
@@ -2099,6 +2100,7 @@ static int mtk_hw_init(struct mtk_eth *eth)
 	if (ret)
 		goto err_disable_pm;
 
+	ethsys_reset(eth, RSTCTRL_ETH);
 	ethsys_reset(eth, RSTCTRL_FE);
 	ethsys_reset(eth, RSTCTRL_PPE);
 
@@ -2129,18 +2131,8 @@ static int mtk_hw_init(struct mtk_eth *eth)
 	for (i = 0; i < MTK_MAC_COUNT; i++)
 		mtk_w32(eth, 0, MTK_MAC_MCR(i));
 
-	/* Indicates CDM to parse the MTK special tag from CPU
-	 * which also is working out for untag packets.
-	 */
-	val = mtk_r32(eth, MTK_CDMQ_IG_CTRL);
-	mtk_w32(eth, val | MTK_CDMQ_STAG_EN, MTK_CDMQ_IG_CTRL);
-
-	/* Disable RX VLan Offloading */
-	mtk_w32(eth, 0, MTK_CDMP_EG_CTRL);
-
-#if defined(CONFIG_NET_DSA)
-	mtk_w32(eth, 0x81000001, MTK_CDMP_IG_CTRL);
-#endif
+	/* Enable RX VLAN Offloading */
+	mtk_w32(eth, 1, MTK_CDMP_EG_CTRL);
 
 	mtk_w32(eth, 0x8f0f8f0f, MTK_PDMA_DELAY_INT);
 	mtk_w32(eth, 0x8f0f8f0f, MTK_QDMA_DELAY_INT);
@@ -2171,8 +2163,8 @@ static int mtk_hw_deinit(struct mtk_eth *eth)
 
 	mtk_clk_disable(eth);
 
-	pm_runtime_put_sync(eth->dev);
-	pm_runtime_disable(eth->dev);
+	/* pm_runtime_put_sync(eth->dev); */
+	/* pm_runtime_disable(eth->dev); */
 
 	return 0;
 }
@@ -2194,6 +2186,7 @@ static int __init mtk_init(struct net_device *dev)
 			dev->dev_addr);
 	}
 
+	mtk_gdma_config(eth, MTK_GDMA_ICS_EN | MTK_GDMA_TCS_EN | MTK_GDMA_UCS_EN);
 	return mtk_phy_connect(dev);
 }
 
@@ -2207,6 +2200,7 @@ static void mtk_uninit(struct net_device *dev)
 		of_phy_deregister_fixed_link(mac->of_node);
 	mtk_tx_irq_disable(eth, ~0);
 	mtk_rx_irq_disable(eth, ~0);
+	mtk_gdma_config(eth, MTK_GDMA_DROP_ALL);
 }
 
 static int mtk_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
@@ -2257,6 +2251,7 @@ static void mtk_pending_work(struct work_struct *work)
 		pinctrl_select_state(eth->dev->pins->p,
 				     eth->dev->pins->default_state);
 	mtk_hw_init(eth);
+	mtk_gdma_config(eth, MTK_GDMA_ICS_EN | MTK_GDMA_TCS_EN | MTK_GDMA_UCS_EN);
 
 	for (i = 0; i < MTK_MAC_COUNT; i++) {
 		if (!eth->mac[i] ||
@@ -2539,6 +2534,7 @@ static const struct net_device_ops mtk_netdev_ops = {
 static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
 {
 	struct mtk_mac *mac;
+	const char *name = of_get_property(np, "label", NULL);
 	const __be32 *_id = of_get_property(np, "reg", NULL);
 	int id, err;
 
@@ -2601,6 +2597,9 @@ static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
 	eth->netdev[id]->irq = eth->irq[0];
 	eth->netdev[id]->dev.of_node = np;
 
+	if (name)
+		strlcpy(eth->netdev[id]->name, name, IFNAMSIZ);
+
 	return 0;
 
 free_netdev:
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_soc.h b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_soc.h
index 027a855..336fc69 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -39,6 +39,8 @@
 				 NETIF_MSG_TX_ERR)
 #define MTK_HW_FEATURES		(NETIF_F_IP_CSUM | \
 				 NETIF_F_RXCSUM | \
+				 NETIF_F_HW_VLAN_CTAG_TX | \
+				 NETIF_F_HW_VLAN_CTAG_RX | \
 				 NETIF_F_SG | NETIF_F_TSO | \
 				 NETIF_F_TSO6 | \
 				 NETIF_F_IPV6_CSUM)
@@ -79,16 +81,19 @@
 
 /* CDMP Ingress Control Register */
 #define MTK_CDMP_IG_CTRL       0x400
+#define MTK_CDMP_STAG_EN	BIT(0)
 
 /* CDMP Exgress Control Register */
 #define MTK_CDMP_EG_CTRL	0x404
 
 /* GDM Exgress Control Register */
 #define MTK_GDMA_FWD_CFG(x)	(0x500 + (x * 0x1000))
+#define MTK_GDMA_SPEC_TAG	BIT(24)
 #define MTK_GDMA_ICS_EN		BIT(22)
 #define MTK_GDMA_TCS_EN		BIT(21)
 #define MTK_GDMA_UCS_EN		BIT(20)
 #define MTK_GDMA_DROP_ALL       0x7777
+#define MTK_GDMA_PDMA_ALL       0x0
 
 /* Unicast Filter MAC Address Register - Low */
 #define MTK_GDMA_MAC_ADRL(x)	(0x508 + (x * 0x1000))
@@ -297,9 +302,12 @@
 #define RX_DMA_DONE		BIT(31)
 #define RX_DMA_PLEN0(_x)	(((_x) & 0x3fff) << 16)
 #define RX_DMA_GET_PLEN0(_x)	(((_x) >> 16) & 0x3fff)
+#define RX_DMA_VTAG             BIT(15)
 
 /* QDMA descriptor rxd3 */
-#define RX_DMA_VID(_x)		((_x) & 0xfff)
+#define RX_DMA_VID(_x)		((_x) & VLAN_VID_MASK)
+#define RX_DMA_TCI(_x)		((_x) & (VLAN_PRIO_MASK | VLAN_VID_MASK))
+#define RX_DMA_VPID(_x)		(((_x) >> 16) & 0xffff)
 
 /* QDMA descriptor rxd4 */
 #define RX_DMA_L4_VALID		BIT(24)
@@ -403,6 +411,7 @@
 #define ETHSYS_RSTCTRL		0x34
 #define RSTCTRL_FE		BIT(6)
 #define RSTCTRL_PPE		BIT(31)
+#define RSTCTRL_ETH		BIT(23)
 
 /* SGMII subsystem config registers */
 /* Register to auto-negotiation restart */
-- 
2.32.0.windows.2

