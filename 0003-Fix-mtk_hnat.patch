From 37557028274472ac4481e079a56c26b35e002316 Mon Sep 17 00:00:00 2001
From: lyh802 <lyh802@126.com>
Date: Wed, 14 Jun 2023 00:22:38 +0800
Subject: [PATCH 3/4] Fix mtk_hnat

---
 .../net/ethernet/raeth/mtk_hnat/Makefile      |   6 +-
 .../net/ethernet/raeth/mtk_hnat/hnat.c        |  93 ++++++++-
 .../net/ethernet/raeth/mtk_hnat/hnat.h        |  35 +++-
 .../ethernet/raeth/mtk_hnat/hnat_debugfs.c    |  71 ++++++-
 .../net/ethernet/raeth/mtk_hnat/hnat_mcast.c  |  11 ++
 .../ethernet/raeth/mtk_hnat/hnat_nf_hook.c    | 177 ++++++++++++------
 .../net/ethernet/raeth/mtk_hnat/hnat_stag.c   |  12 +-
 .../net/ethernet/raeth/mtk_hnat/nf_hnat_mtk.h |  18 +-
 8 files changed, 336 insertions(+), 87 deletions(-)

diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/Makefile b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/Makefile
index bf1bbcbc..d3c36099 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/Makefile
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/Makefile
@@ -1,5 +1,5 @@
 ccflags-y=-Werror
 
-obj-$(CONFIG_NET_MEDIATEK_HNAT)         += mtkhnat.o
-mtkhnat-objs := hnat.o hnat_nf_hook.o hnat_debugfs.o hnat_mcast.o
-mtkhnat-$(CONFIG_NET_DSA_MT7530)	+= hnat_stag.o
+obj-$(CONFIG_NET_MEDIATEK_HNAT)         += hw_nat.o
+hw_nat-objs := hnat.o hnat_nf_hook.o hnat_debugfs.o hnat_mcast.o
+hw_nat-$(CONFIG_NET_DSA_MT7530)	+= hnat_stag.o
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.c b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.c
index a3eef581..d37690f1 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.c
@@ -20,6 +20,7 @@
 #include <linux/platform_device.h>
 #include <linux/reset.h>
 #include <linux/rtnetlink.h>
+#include <linux/version.h>
 #include <net/netlink.h>
 
 #include "nf_hnat_mtk.h"
@@ -29,22 +30,36 @@ struct mtk_hnat *hnat_priv;
 static struct socket *_hnat_roam_sock;
 static struct work_struct _hnat_roam_work;
 
+#if defined(CONFIG_RA_NAT_HW)
+extern int (*ra_sw_nat_hook_rx)(struct sk_buff *skb);
+extern int (*ra_sw_nat_hook_tx)(struct sk_buff *skb, int gmac_no);
+#else
 int (*ra_sw_nat_hook_rx)(struct sk_buff *skb) = NULL;
 EXPORT_SYMBOL(ra_sw_nat_hook_rx);
 int (*ra_sw_nat_hook_tx)(struct sk_buff *skb, int gmac_no) = NULL;
 EXPORT_SYMBOL(ra_sw_nat_hook_tx);
+#endif
 void (*ra_sw_nat_clear_bind_entries)(void) = NULL;
 EXPORT_SYMBOL(ra_sw_nat_clear_bind_entries);
 
 int (*ppe_del_entry_by_mac)(unsigned char *mac) = NULL;
 EXPORT_SYMBOL(ppe_del_entry_by_mac);
 
+#if defined(CONFIG_RA_NAT_HW)
+extern void (*ppe_dev_register_hook)(struct net_device *dev);
+extern void (*ppe_dev_unregister_hook)(struct net_device *dev);
+#else
 void (*ppe_dev_register_hook)(struct net_device *dev) = NULL;
 EXPORT_SYMBOL(ppe_dev_register_hook);
 void (*ppe_dev_unregister_hook)(struct net_device *dev) = NULL;
 EXPORT_SYMBOL(ppe_dev_unregister_hook);
+#endif
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0))
+static void hnat_sma_build_entry(unsigned long data)
+#else
 static void hnat_sma_build_entry(struct timer_list *t)
+#endif
 {
 	int i;
 
@@ -64,7 +79,11 @@ void hnat_cache_ebl(int enable)
 	}
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0))
+static void hnat_reset_timestamp(unsigned long data)
+#else
 static void hnat_reset_timestamp(struct timer_list *t)
+#endif
 {
 	struct foe_entry *entry;
 	int hash_index;
@@ -330,10 +349,12 @@ static int hnat_hw_init(u32 ppe_id)
 
 	/* enable FOE */
 	cr_set_bits(hnat_priv->ppe_base[ppe_id] + PPE_FLOW_CFG,
-		    BIT_IPV4_NAT_EN | BIT_IPV4_NAPT_EN |
+		    //BIT_IPV4_NAT_EN | BIT_IPV4_NAPT_EN |
+		    BIT_TCP_IP4F_NAT_EN | BIT_UDP_IP4F_NAT_EN | BIT_IPV4_NAT_EN | BIT_IPV4_NAPT_EN |
 		    BIT_IPV4_NAT_FRAG_EN | BIT_IPV4_HASH_GREK |
 		    BIT_IPV4_DSL_EN | BIT_IPV6_6RD_EN |
-		    BIT_IPV6_3T_ROUTE_EN | BIT_IPV6_5T_ROUTE_EN);
+		    //BIT_IPV6_3T_ROUTE_EN | BIT_IPV6_5T_ROUTE_EN);
+		    BIT_IPV6_3T_ROUTE_EN | BIT_IPV6_5T_ROUTE_EN | BIT_IPV6_HASH_GREK);
 
 	if (hnat_priv->data->version == MTK_HNAT_V2 ||
 	    hnat_priv->data->version == MTK_HNAT_V3)
@@ -383,10 +404,15 @@ static int hnat_hw_init(u32 ppe_id)
 
 	/* setup FOE cf gen */
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_GLO_CFG, PPE_EN, 1);
+#if defined(CONFIG_RAETH_QDMATX_QDMARX) || defined(CONFIG_RAETH_PDMATX_QDMARX)
+	writel(0x55555555, hnat_priv->ppe_base[ppe_id] + PPE_DFT_CPORT); /* qdma */
+#else
 	writel(0, hnat_priv->ppe_base[ppe_id] + PPE_DFT_CPORT); /* pdma */
 	/* writel(0x55555555, hnat_priv->ppe_base[ppe_id] + PPE_DFT_CPORT); */ /* qdma */
+#endif
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_GLO_CFG, TTL0_DRP, 0);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_GLO_CFG, MCAST_TB_EN, 1);
+	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_GLO_CFG, MCAST_HASH, 0);
 
 	if (hnat_priv->data->version == MTK_HNAT_V2 ||
 	    hnat_priv->data->version == MTK_HNAT_V3) {
@@ -497,6 +523,8 @@ static void hnat_stop(u32 ppe_id)
 	u32 foe_table_sz;
 	u32 foe_mib_tb_sz;
 	struct foe_entry *entry, *end;
+	//TODO:
+	u32 r1 = 0, r2 = 0;
 
 	if (ppe_id >= CFG_PPE_NUM)
 		return;
@@ -533,7 +561,8 @@ static void hnat_stop(u32 ppe_id)
 		    BIT_IPV4_NAPT_EN | BIT_IPV4_NAT_EN | BIT_IPV4_NAT_FRAG_EN |
 		    BIT_IPV6_HASH_GREK | BIT_IPV4_DSL_EN |
 		    BIT_IPV6_6RD_EN | BIT_IPV6_3T_ROUTE_EN |
-		    BIT_IPV6_5T_ROUTE_EN | BIT_FUC_FOE | BIT_FMC_FOE);
+		    //BIT_IPV6_5T_ROUTE_EN | BIT_FUC_FOE | BIT_FMC_FOE);
+		    BIT_IPV6_5T_ROUTE_EN | BIT_IPV6_HASH_GREK | BIT_FUC_FOE | BIT_FMC_FOE | BIT_FBC_FOE);
 
 	if (hnat_priv->data->version == MTK_HNAT_V2 ||
 	    hnat_priv->data->version == MTK_HNAT_V3)
@@ -552,6 +581,18 @@ static void hnat_stop(u32 ppe_id)
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, UDP_AGE, 0);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, FIN_AGE, 0);
 
+	//TODO:
+	r1 = readl(hnat_priv->fe_base + 0x100);
+	r2 = readl(hnat_priv->fe_base + 0x10c);
+
+	dev_info(hnat_priv->dev, "0x100 = 0x%x, 0x10c = 0x%x\n", r1, r2);
+
+	if (((r1 & 0xff00) >> 0x8) >= (r1 & 0xff) ||
+	    ((r1 & 0xff00) >> 0x8) >= (r2 & 0xff)) {
+		dev_info(hnat_priv->dev, "reset pse\n");
+		writel(0x1, hnat_priv->fe_base + 0x4);
+	}
+
 	/* free the FOE table */
 	foe_table_sz = hnat_priv->foe_etry_num * sizeof(struct foe_entry);
 	if (hnat_priv->foe_table_cpu[ppe_id])
@@ -605,13 +646,20 @@ int hnat_enable_hook(void)
 	/* register hook functions used by WHNAT module.
 	 */
 	if (hnat_priv->data->whnat) {
-		ra_sw_nat_hook_rx =
+		/*ra_sw_nat_hook_rx =
 			(hnat_priv->data->version == MTK_HNAT_V2 ||
 			 hnat_priv->data->version == MTK_HNAT_V3) ?
-			 mtk_sw_nat_hook_rx : NULL;
+			 mtk_sw_nat_hook_rx : NULL;*/
+		ra_sw_nat_hook_rx = mtk_sw_nat_hook_rx;
 		ra_sw_nat_hook_tx = mtk_sw_nat_hook_tx;
-		ppe_dev_register_hook = mtk_ppe_dev_register_hook;
-		ppe_dev_unregister_hook = mtk_ppe_dev_unregister_hook;
+		/*ppe_dev_register_hook = mtk_ppe_dev_register_hook;
+		ppe_dev_unregister_hook = mtk_ppe_dev_unregister_hook;*/
+		if (hnat_priv->data->version == MTK_HNAT_V1_2 ||
+		    hnat_priv->data->version == MTK_HNAT_V2 ||
+		    hnat_priv->data->version == MTK_HNAT_V3) {
+			ppe_dev_register_hook = mtk_ppe_dev_register_hook;
+			ppe_dev_unregister_hook = mtk_ppe_dev_unregister_hook;
+		}
 		ra_sw_nat_clear_bind_entries = foe_clear_all_bind_entries;
 	}
 
@@ -736,21 +784,33 @@ static int hnat_probe(struct platform_device *pdev)
 
 	err = of_property_read_string(np, "mtketh-lan", &name);
 	if (err < 0)
+#if defined(CONFIG_SUPPORT_OPENWRT)
 		strncpy(hnat_priv->lan, "eth0", IFNAMSIZ);
+#else
+		strncpy(hnat_priv->lan, "eth2", IFNAMSIZ);
+#endif
 	else
 		strncpy(hnat_priv->lan, (char *)name, IFNAMSIZ - 1);
 	dev_info(&pdev->dev, "lan = %s\n", hnat_priv->lan);
 
 	err = of_property_read_string(np, "mtketh-lan2", &name);
 	if (err < 0)
+#if defined(CONFIG_SUPPORT_OPENWRT)
 		strncpy(hnat_priv->lan2, "eth2", IFNAMSIZ);
+#else
+		strncpy(hnat_priv->lan2, "eth4", IFNAMSIZ);
+#endif
 	else
 		strncpy(hnat_priv->lan2, (char *)name, IFNAMSIZ - 1);
 	dev_info(&pdev->dev, "lan2 = %s\n", hnat_priv->lan2);
 
 	err = of_property_read_string(np, "mtketh-ppd", &name);
 	if (err < 0)
+#if defined(CONFIG_SUPPORT_OPENWRT)
 		strncpy(hnat_priv->ppd, "eth0", IFNAMSIZ);
+#else
+		strncpy(hnat_priv->ppd, "eth2", IFNAMSIZ);
+#endif
 	else
 		strncpy(hnat_priv->ppd, (char *)name, IFNAMSIZ - 1);
 	dev_info(&pdev->dev, "ppd = %s\n", hnat_priv->ppd);
@@ -804,6 +864,9 @@ static int hnat_probe(struct platform_device *pdev)
 	hnat_priv->ppe_base[0] = hnat_priv->fe_base + 0xe00;
 #endif
 
+	hnat_priv->ipv6_en = true; /* enable ipv6 by default */
+	hnat_priv->guest_en = true; /* enable guest wifi by default */
+
 	err = hnat_init_debugfs(hnat_priv);
 	if (err)
 		return err;
@@ -852,9 +915,19 @@ static int hnat_probe(struct platform_device *pdev)
 			hnat_mcast_enable(i);
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0))
+	init_timer(&hnat_priv->hnat_sma_build_entry_timer);
+	hnat_priv->hnat_sma_build_entry_timer.function = hnat_sma_build_entry;
+#else
 	timer_setup(&hnat_priv->hnat_sma_build_entry_timer, hnat_sma_build_entry, 0);
+#endif
 	if (hnat_priv->data->version == MTK_HNAT_V1_3) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0))
+		init_timer(&hnat_priv->hnat_reset_timestamp_timer);
+		hnat_priv->hnat_reset_timestamp_timer.function = hnat_reset_timestamp;
+#else
 		timer_setup(&hnat_priv->hnat_reset_timestamp_timer, hnat_reset_timestamp, 0);
+#endif
 		hnat_priv->hnat_reset_timestamp_timer.expires = jiffies;
 		add_timer(&hnat_priv->hnat_reset_timestamp_timer);
 	}
@@ -912,7 +985,8 @@ static int hnat_remove(struct platform_device *pdev)
 
 static const struct mtk_hnat_data hnat_data_v1 = {
 	.num_of_sch = 2,
-	.whnat = false,
+	//.whnat = false,
+	.whnat = true,
 	.per_flow_accounting = false,
 	.mcast = false,
 	.version = MTK_HNAT_V1_1,
@@ -928,7 +1002,8 @@ static const struct mtk_hnat_data hnat_data_v2 = {
 
 static const struct mtk_hnat_data hnat_data_v3 = {
 	.num_of_sch = 4,
-	.whnat = false,
+	//.whnat = false,
+	.whnat = true,
 	.per_flow_accounting = false,
 	.mcast = false,
 	.version = MTK_HNAT_V1_3,
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.h b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.h
index 331fce9c..e1dbb516 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.h
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.h
@@ -108,6 +108,12 @@
 #define GDMA2_FWD_CFG 0x1500
 #define GDMA3_FWD_CFG 0x540
 
+#if defined(CONFIG_MEDIATEK_NETSYS_V2) || defined(CONFIG_MEDIATEK_NETSYS_V3)
+#define QDMA_BASE               0x4400
+#else
+#define QDMA_BASE               0x1800
+#endif
+
 /* QDMA Tx queue configuration */
 #define QTX_CFG(x)			(QDMA_BASE + ((x) * 0x10))
 #define QTX_CFG_HW_RESV_CNT_OFFSET	(8)
@@ -183,6 +189,7 @@
 
 /*PPE_GLO_CFG mask*/
 #define PPE_EN (0x1 << 0) /* RW */
+#define TSID_EN (0x1 << 1) /* RW */
 #define TTL0_DRP (0x1 << 4) /* RW */
 #define MCAST_TB_EN (0x1 << 7) /* RW */
 #define MCAST_HASH (0x3 << 12) /* RW */
@@ -431,7 +438,8 @@ struct hnat_ipv4_dslite {
 	u32 tunnel_dipv6_3;
 
 	u8 flow_lbl[3]; /* in order to consist with Linux kernel (should be 20bits) */
-	u8 priority;    /* in order to consist with Linux kernel (should be 8bits) */
+	u8 priority : 4;    /* in order to consist with Linux kernel (should be 8bits) */
+	u8 resv1 : 4;
 	u32 hop_limit : 8;
 	u32 resv2 : 18;
 	u32 act_dp : 6; /* UDF */
@@ -493,7 +501,8 @@ struct hnat_ipv4_mape {
 	u32 tunnel_dipv6_3;
 
 	u8 flow_lbl[3]; /* in order to consist with Linux kernel (should be 20bits) */
-	u8 priority;    /* in order to consist with Linux kernel (should be 8bits) */
+	u8 priority : 4;    /* in order to consist with Linux kernel (should be 8bits) */
+	u8 resv1 : 4;
 	u32 hop_limit : 8;
 	u32 resv2 : 18;
 	u32 act_dp : 6; /* UDF */
@@ -802,9 +811,11 @@ struct foe_entry {
 /* If user wants to change default FOE entry number, both DEF_ETRY_NUM and
  * DEF_ETRY_NUM_CFG need to be modified.
  */
-#define DEF_ETRY_NUM		8192
+//#define DEF_ETRY_NUM		8192
+#define DEF_ETRY_NUM		16384
 /* feasible values : 32768, 16384, 8192, 4096, 2048, 1024 */
-#define DEF_ETRY_NUM_CFG	TABLE_8K
+//#define DEF_ETRY_NUM_CFG	TABLE_8K
+#define DEF_ETRY_NUM_CFG	TABLE_16K
 /* corresponding values : TABLE_32K, TABLE_16K, TABLE_8K, TABLE_4K, TABLE_2K,
  * TABLE_1K
  */
@@ -904,6 +915,8 @@ struct mtk_hnat {
 	struct timer_list hnat_mcast_check_timer;
 	bool nf_stat_en;
 	struct xlat_conf xlat;
+	bool ipv6_en;
+	bool guest_en;
 };
 
 struct extdev_entry {
@@ -925,8 +938,13 @@ enum FoeIpAct {
 	IPV6_3T_ROUTE = 4,
 	IPV6_5T_ROUTE = 5,
 	IPV6_6RD = 7,
+/*#if defined(CONFIG_MEDIATEK_NETSYS_V2) || defined(CONFIG_MEDIATEK_NETSYS_V3)*/
 	IPV4_MAP_T = 8,
 	IPV4_MAP_E = 9,
+/*#else
+	IPV4_MAP_T = 6,
+	IPV4_MAP_E = 6,
+#endif*/
 	IPV6_HNAPT = 10,
 	IPV6_HNAT = 11,
 };
@@ -942,6 +960,7 @@ enum FoeIpAct {
 #define ENTRY_128B 0
 #define ENTRY_96B 1
 #define ENTRY_80B 1
+#define ENTRY_64B 0
 #define TABLE_1K 0
 #define TABLE_2K 1
 #define TABLE_4K 2
@@ -961,6 +980,7 @@ enum FoeIpAct {
 #define BIT_FUC_FOE BIT(2)
 #define BIT_FMC_FOE BIT(1)
 #define BIT_FBC_FOE BIT(0)
+#define BIT_TCP_IP4F_NAT_EN BIT(6)
 #define BIT_UDP_IP4F_NAT_EN BIT(7) /*Enable IPv4 fragment + UDP packet NAT*/
 #define BIT_IPV6_3T_ROUTE_EN BIT(8)
 #define BIT_IPV6_5T_ROUTE_EN BIT(9)
@@ -971,6 +991,7 @@ enum FoeIpAct {
 #define BIT_IPV4_DSL_EN BIT(14)
 #define BIT_MIB_BUSY BIT(16)
 #define BIT_IPV4_NAT_FRAG_EN BIT(17)
+#define BIT_IPV6_HASH_FLAB BIT(18)
 #define BIT_IPV4_HASH_GREK BIT(19)
 #define BIT_IPV6_HASH_GREK BIT(20)
 #define BIT_IPV4_MAPE_EN BIT(21)
@@ -1188,7 +1209,8 @@ static inline int is_hnat_pre_filled(struct foe_entry *entry)
 #if defined(CONFIG_NET_DSA_MT7530)
 u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 		       struct foe_entry *entry,
-		       struct flow_offload_hw_path *hw_path,
+		       //struct flow_offload_hw_path *hw_path,
+		       struct hnat_hw_path *hw_path,
 		       u16 eth_proto, int mape);
 
 static inline bool hnat_dsa_is_enable(struct mtk_hnat *priv)
@@ -1198,7 +1220,8 @@ static inline bool hnat_dsa_is_enable(struct mtk_hnat *priv)
 #else
 static inline u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 				     struct foe_entry *entry,
-				     struct flow_offload_hw_path *hw_path,
+				     //struct flow_offload_hw_path *hw_path,
+				     struct hnat_hw_path *hw_path,
 				     u16 eth_proto, int mape)
 {
 	return 0;
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_debugfs.c b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_debugfs.c
index f6483869..65cb98d1 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_debugfs.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_debugfs.c
@@ -29,9 +29,9 @@ int debug_level;
 int dbg_cpu_reason;
 int hook_toggle;
 int mape_toggle;
-int qos_toggle;
-int qos_dl_toggle = 1;
-int qos_ul_toggle = 1;
+int qos_toggle = 0;
+int qos_dl_toggle = 0;
+int qos_ul_toggle = 0;
 int xlat_toggle;
 struct hnat_desc headroom[DEF_ETRY_NUM];
 unsigned int dbg_cpu_reason_cnt[MAX_CRSN_NUM];
@@ -701,7 +701,9 @@ int cr_set_usage(int level)
 	pr_info("              4     0~65535    Set UDP bind lifetime\n");
 	pr_info("              5     0~255      Set TCP keep alive interval\n");
 	pr_info("              6     0~255      Set UDP keep alive interval\n");
-	pr_info("              7     0~1        Set hnat counter update to nf_conntrack\n");
+	pr_info("              9     0~1        Set hnat counter update to nf_conntrack\n");
+	pr_info("              7     0~1        Set hnat disable/enable ipv6\n");
+	pr_info("              8     0~1        Set hnat disable/enable guest (rax1/rai1/ra1)\n");
 
 	return 0;
 }
@@ -813,6 +815,62 @@ int set_nf_update_toggle(int toggle)
 	return 0;
 }
 
+int set_ipv6_toggle(int toggle)
+{
+	struct mtk_hnat *h = hnat_priv;
+
+	if (toggle == 1)
+		pr_info("Enable hnat ipv6\n");
+	else if (toggle == 0)
+		pr_info("Disable hnat ipv6\n");
+	else {
+		pr_info("input error, current ipv6_en=%d\n", h->ipv6_en);
+		return 0;
+	}
+	h->ipv6_en = toggle;
+
+	return 0;
+}
+
+void mtk_ppe_dev_hook(const char *name, int toggle)
+{
+	struct net_device *dev;
+	dev = dev_get_by_name(&init_net, name);
+	if (dev) {
+		if (toggle) {
+			mtk_ppe_dev_register_hook(dev);
+		} else {
+			mtk_ppe_dev_unregister_hook(dev);
+		}
+		dev_put(dev);
+	}
+	return;
+}
+
+int set_guest_toggle(int toggle)
+{
+	struct mtk_hnat *h = hnat_priv;
+
+	if (toggle == 1)
+		pr_info("Enable hnat guest interface\n");
+	else if (toggle == 0)
+		pr_info("Disable hnat guest interface\n");
+	else {
+		pr_info("input error, current guest_en=%d\n", h->guest_en);
+		return 0;
+	}
+	h->guest_en = toggle;
+
+	if (hnat_priv->data->version == MTK_HNAT_V1_2 ||
+	    hnat_priv->data->version == MTK_HNAT_V2 ||
+	    hnat_priv->data->version == MTK_HNAT_V3) {
+		mtk_ppe_dev_hook("ra1", toggle);
+		mtk_ppe_dev_hook("rai1", toggle);
+		mtk_ppe_dev_hook("rax1", toggle);
+	}
+	return 0;
+}
+
 static const debugfs_write_func hnat_set_func[] = {
 	[0] = hnat_set_usage,
 	[1] = hnat_cpu_reason,
@@ -831,7 +889,8 @@ static const debugfs_write_func cr_set_func[] = {
 	[0] = cr_set_usage,      [1] = binding_threshold,
 	[2] = tcp_bind_lifetime, [3] = fin_bind_lifetime,
 	[4] = udp_bind_lifetime, [5] = tcp_keep_alive,
-	[6] = udp_keep_alive,    [7] = set_nf_update_toggle,
+	[6] = udp_keep_alive,    [9] = set_nf_update_toggle,
+	[7] = set_ipv6_toggle,   [8] = set_guest_toggle,
 };
 
 int read_mib(struct mtk_hnat *h, u32 ppe_id,
@@ -1840,6 +1899,8 @@ ssize_t hnat_setting_write(struct file *file, const char __user *buffer,
 	case 5:
 	case 6:
 	case 7:
+	case 8:
+	case 9:
 		p_token = strsep(&p_buf, p_delimiter);
 		if (!p_token)
 			arg1 = 0;
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_mcast.c b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_mcast.c
index edf17cb4..b05c49ce 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_mcast.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_mcast.c
@@ -13,6 +13,7 @@
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
 #include <linux/if_bridge.h>
+#include <linux/version.h>
 #include "hnat.h"
 
 /* *
@@ -256,7 +257,11 @@ out:
 	return NULL;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0))
+static void hnat_mcast_check_timestamp(unsigned long data)
+#else
 static void hnat_mcast_check_timestamp(struct timer_list *t)
+#endif
 {
 	struct foe_entry *entry;
 	int i, hash_index;
@@ -307,8 +312,14 @@ int hnat_mcast_enable(u32 ppe_id)
 
 	/* mt7629 should checkout mcast entry life time manualy */
 	if (hnat_priv->data->version == MTK_HNAT_V1_3) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0))
+		init_timer(&hnat_priv->hnat_mcast_check_timer);
+		hnat_priv->hnat_mcast_check_timer.function =
+			hnat_mcast_check_timestamp;
+#else
 		timer_setup(&hnat_priv->hnat_mcast_check_timer,
 			    hnat_mcast_check_timestamp, 0);
+#endif
 		hnat_priv->hnat_mcast_check_timer.expires = jiffies;
 		add_timer(&hnat_priv->hnat_mcast_check_timer);
 	}
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c
index d34ac9de..3cebba0e 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c
@@ -13,11 +13,13 @@
 
 #include <linux/netfilter_bridge.h>
 #include <linux/netfilter_ipv6.h>
+#include <linux/version.h>
 
 #include <net/arp.h>
 #include <net/neighbour.h>
 #include <net/netfilter/nf_conntrack_helper.h>
-#include <net/netfilter/nf_flow_table.h>
+//#include <net/netfilter/nf_flow_table.h>
+#include <net/netfilter/nf_hnat.h>
 #include <net/ipv6.h>
 #include <net/ip6_route.h>
 #include <net/ip.h>
@@ -30,7 +32,7 @@
 #include "hnat.h"
 
 #include "../mtk_eth_soc.h"
-#include "../mtk_eth_reset.h"
+//#include "../mtk_eth_reset.h"
 
 #define do_ge2ext_fast(dev, skb)                                               \
 	((IS_LAN_GRP(dev) || IS_WAN(dev) || IS_PPD(dev)) && \
@@ -228,6 +230,11 @@ int nf_hnat_netdevice_event(struct notifier_block *unused, unsigned long event,
 
 	switch (event) {
 	case NETDEV_UP:
+		if (!hnat_priv->guest_en && dev->name) {
+			if (!strcmp(dev->name, "ra1") || !strcmp(dev->name, "rai1") || !strcmp(dev->name, "rax1"))
+				break;
+		}
+
 		gmac_ppe_fwd_enable(dev);
 
 		extif_set_dev(dev);
@@ -239,7 +246,8 @@ int nf_hnat_netdevice_event(struct notifier_block *unused, unsigned long event,
 
 		if (!IS_LAN_GRP(dev) && !IS_WAN(dev) &&
 		    !find_extif_from_devname(dev->name) &&
-		    !dev->netdev_ops->ndo_flow_offload_check)
+		    //!dev->netdev_ops->ndo_flow_offload_check)
+		    !dev->netdev_ops->ndo_hnat_check)
 			break;
 
 		foe_clear_all_bind_entries();
@@ -263,10 +271,10 @@ int nf_hnat_netdevice_event(struct notifier_block *unused, unsigned long event,
 			hnat_priv->g_wandev = dev_get_by_name(&init_net, hnat_priv->wan);
 
 		break;
-	case MTK_FE_RESET_NAT_DONE:
+	/*TODO:case MTK_FE_RESET_NAT_DONE:
 		pr_info("[%s] HNAT driver starts to do warm init !\n", __func__);
 		hnat_warm_init();
-		break;
+		break;*/
 	default:
 		break;
 	}
@@ -292,11 +300,13 @@ void foe_clear_entry(struct neighbour *neigh)
 			entry = hnat_priv->foe_table_cpu[i] + hash_index;
 			if (entry->bfib1.state == BIND &&
 			    entry->ipv4_hnapt.new_dip == ntohl(dip) &&
-			    IS_IPV4_HNAPT(entry)) {
+			    //IS_IPV4_HNAPT(entry)) {
+			    IS_IPV4_GRP(entry)) {
 				*((u32 *)h_dest) = swab32(entry->ipv4_hnapt.dmac_hi);
 				*((u16 *)&h_dest[4]) =
 					swab16(entry->ipv4_hnapt.dmac_lo);
-				if (strncmp(h_dest, neigh->ha, ETH_ALEN) != 0) {
+				//if (strncmp(h_dest, neigh->ha, ETH_ALEN) != 0) {
+				if (!ether_addr_equal(h_dest, neigh->ha)) {
 					cr_set_field(hnat_priv->ppe_base[i] + PPE_TB_CFG,
 						     SMA, SMA_ONLY_FWD_CPU);
 
@@ -385,22 +395,25 @@ unsigned int do_hnat_ext_to_ge(struct sk_buff *skb, const struct net_device *in,
 			       const char *func)
 {
 	if (hnat_priv->g_ppdev && hnat_priv->g_ppdev->flags & IFF_UP) {
-		u16 vlan_id = 0;
+		//u16 vlan_id = 0;
 		skb_set_network_header(skb, 0);
 		skb_push(skb, ETH_HLEN);
 		set_to_ppe(skb);
 
-		vlan_id = skb_vlan_tag_get_id(skb);
+		/*vlan_id = skb_vlan_tag_get_id(skb);
 		if (vlan_id) {
 			skb = vlan_insert_tag(skb, skb->vlan_proto, skb->vlan_tci);
-			if (!skb)
+			if (!skb)*/
+		if (skb_vlan_tag_present(skb)) {
+			if (__vlan_insert_tag(skb, skb->vlan_proto, skb_vlan_tag_get(skb)))
 				return -1;
 		}
 
 		/*set where we come from*/
-		skb->vlan_proto = htons(ETH_P_8021Q);
+		/*skb->vlan_proto = htons(ETH_P_8021Q);
 		skb->vlan_tci =
-			(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));
+			(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));*/
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), in->ifindex & VLAN_VID_MASK);
 		trace_printk(
 			"%s: vlan_prot=0x%x, vlan_tci=%x, in->name=%s, skb->dev->name=%s\n",
 			__func__, ntohs(skb->vlan_proto), skb->vlan_tci,
@@ -498,13 +511,13 @@ unsigned int do_hnat_ge_to_ext(struct sk_buff *skb, const char *func)
 		index = entry->ipv6_5t_route.act_dp & UDF_PINGPONG_IFIDX;
 
 	dev = get_dev_from_index(index);
-	if (!dev) {
+	/*if (!dev) {
 		trace_printk("%s: called from %s. Get wifi interface fail\n",
 			     __func__, func);
 		return 0;
 	}
 
-	skb->dev = dev;
+	skb->dev = dev;*/
 
 	if (IS_HQOS_MODE && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 		skb = skb_unshare(skb, GFP_ATOMIC);
@@ -520,7 +533,9 @@ unsigned int do_hnat_ge_to_ext(struct sk_buff *skb, const char *func)
 			2 * ETH_ALEN);
 	}
 
-	if (skb->dev) {
+	//if (skb->dev) {
+	if (dev) {
+		skb->dev = dev;
 		skb_set_network_header(skb, 0);
 		skb_push(skb, ETH_HLEN);
 		dev_queue_xmit(skb);
@@ -600,7 +615,8 @@ static inline void hnat_set_iif(const struct nf_hook_state *state,
 	} else if (IS_WAN(state->in)) {
 		skb_hnat_iface(skb) = FOE_MAGIC_GE_WAN;
 	} else if (!IS_BR(state->in)) {
-		if (state->in->netdev_ops->ndo_flow_offload_check) {
+		//if (state->in->netdev_ops->ndo_flow_offload_check) {
+		if (state->in->netdev_ops->ndo_hnat_check) {
 			skb_hnat_iface(skb) = FOE_MAGIC_GE_VIRTUAL;
 		} else {
 			skb_hnat_iface(skb) = FOE_INVALID;
@@ -674,9 +690,10 @@ unsigned int do_hnat_mape_w2l_fast(struct sk_buff *skb, const struct net_device
 		eth->h_proto = htons(ETH_P_IP);
 		set_to_ppe(skb);
 
-		skb->vlan_proto = htons(ETH_P_8021Q);
+		/*skb->vlan_proto = htons(ETH_P_8021Q);
 		skb->vlan_tci =
-		(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));
+		(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));*/
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), in->ifindex & VLAN_VID_MASK);
 
 		if (!hnat_priv->g_ppdev)
 			hnat_priv->g_ppdev = dev_get_by_name(&init_net, hnat_priv->ppd);
@@ -703,11 +720,13 @@ void mtk_464xlat_pre_process(struct sk_buff *skb)
 	if (foe->bfib1.state != BIND &&
 	    skb_hnat_reason(skb) == HIT_UNBIND_RATE_REACH)
 		memcpy(&headroom[skb_hnat_entry(skb)], skb->head,
-		       sizeof(struct hnat_desc));
+		       //sizeof(struct hnat_desc));
+		       FOE_INFO_LEN);
 
 	if (foe->bfib1.state == BIND)
 		memset(&headroom[skb_hnat_entry(skb)], 0,
-		       sizeof(struct hnat_desc));
+		       //sizeof(struct hnat_desc));
+		       FOE_INFO_LEN);
 }
 
 static unsigned int is_ppe_support_type(struct sk_buff *skb)
@@ -720,6 +739,8 @@ static unsigned int is_ppe_support_type(struct sk_buff *skb)
 	eth = eth_hdr(skb);
 	if (!is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb) ||
 	    is_broadcast_ether_addr(eth->h_dest))
+	/*if (!is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb) ||
+	    is_multicast_ether_addr(eth->h_dest))*/
 		return 0;
 
 	switch (ntohs(skb->protocol)) {
@@ -830,8 +851,8 @@ static unsigned int
 mtk_hnat_ipv4_nf_pre_routing(void *priv, struct sk_buff *skb,
 			     const struct nf_hook_state *state)
 {
-	struct flow_offload_hw_path hw_path = { .dev = skb->dev,
-						.virt_dev = skb->dev };
+	/*TODO:struct flow_offload_hw_path hw_path = { .dev = skb->dev,
+						.virt_dev = skb->dev };*/
 
 	if (!skb)
 		goto drop;
@@ -851,13 +872,13 @@ mtk_hnat_ipv4_nf_pre_routing(void *priv, struct sk_buff *skb,
 	 * In pre-routing, if dev is virtual iface, TOPS module is not loaded,
 	 * and it's L2TP flow, then do not bind.
 	 */
-	if (skb_hnat_iface(skb) == FOE_MAGIC_GE_VIRTUAL
+	/*TODO:if (skb_hnat_iface(skb) == FOE_MAGIC_GE_VIRTUAL
 	    && skb->dev->netdev_ops->ndo_flow_offload_check) {
 		skb->dev->netdev_ops->ndo_flow_offload_check(&hw_path);
 
 		if (hw_path.flags & FLOW_OFFLOAD_PATH_TNL)
 			skb_hnat_alg(skb) = 1;
-	}
+	}*/
 
 	pre_routing_print(skb, state->in, state->out, __func__);
 
@@ -985,15 +1006,18 @@ drop:
 
 static unsigned int hnat_ipv6_get_nexthop(struct sk_buff *skb,
 					  const struct net_device *out,
-					  struct flow_offload_hw_path *hw_path)
+					  //struct flow_offload_hw_path *hw_path)
+					  struct hnat_hw_path *hw_path)
 {
-	const struct in6_addr *ipv6_nexthop;
+	//const struct in6_addr *ipv6_nexthop;
+	struct in6_addr *ipv6_nexthop;
 	struct neighbour *neigh = NULL;
 	struct dst_entry *dst = skb_dst(skb);
 	struct ethhdr *eth;
 	u16 eth_pppoe_hlen = ETH_HLEN + PPPOE_SES_HLEN;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
+	//if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
+	if (hw_path->flags & HNAT_PATH_PPPOE) {
 		if (ipv6_hdr(skb)->nexthdr == NEXTHDR_IPIP) {
 			eth = (struct ethhdr *)(skb->data - eth_pppoe_hlen);
 			eth->h_proto = skb->protocol;
@@ -1043,7 +1067,8 @@ static unsigned int hnat_ipv6_get_nexthop(struct sk_buff *skb,
 
 static unsigned int hnat_ipv4_get_nexthop(struct sk_buff *skb,
 					  const struct net_device *out,
-					  struct flow_offload_hw_path *hw_path)
+					  //struct flow_offload_hw_path *hw_path)
+					  struct hnat_hw_path *hw_path)
 {
 	u32 nexthop;
 	struct neighbour *neigh;
@@ -1051,7 +1076,8 @@ static unsigned int hnat_ipv4_get_nexthop(struct sk_buff *skb,
 	struct rtable *rt = (struct rtable *)dst;
 	struct net_device *dev = (__force struct net_device *)out;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
+	//if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
+	if (hw_path->flags & HNAT_PATH_PPPOE) {
 		memcpy(eth_hdr(skb)->h_source, hw_path->eth_src, ETH_ALEN);
 		memcpy(eth_hdr(skb)->h_dest, hw_path->eth_dest, ETH_ALEN);
 		return 0;
@@ -1102,7 +1128,8 @@ static u16 ppe_get_chkbase(struct iphdr *iph)
 }
 
 struct foe_entry ppe_fill_L2_info(struct ethhdr *eth, struct foe_entry entry,
-				  struct flow_offload_hw_path *hw_path)
+				  //struct flow_offload_hw_path *hw_path)
+				  struct hnat_hw_path *hw_path)
 {
 	switch ((int)entry.bfib1.pkt_type) {
 	case IPV4_HNAPT:
@@ -1132,10 +1159,13 @@ struct foe_entry ppe_fill_L2_info(struct ethhdr *eth, struct foe_entry entry,
 }
 
 struct foe_entry ppe_fill_info_blk(struct ethhdr *eth, struct foe_entry entry,
-				   struct flow_offload_hw_path *hw_path)
+				   //struct flow_offload_hw_path *hw_path)
+				   struct hnat_hw_path *hw_path)
 {
-	entry.bfib1.psn = (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) ? 1 : 0;
-	entry.bfib1.vlan_layer += (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ? 1 : 0;
+	//entry.bfib1.psn = (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) ? 1 : 0;
+	//entry.bfib1.vlan_layer += (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ? 1 : 0;
+	entry.bfib1.psn = (hw_path->flags & HNAT_PATH_PPPOE) ? 1 : 0;
+	entry.bfib1.vlan_layer += (hw_path->flags & HNAT_PATH_VLAN) ? 1 : 0;
 	entry.bfib1.vpm = (entry.bfib1.vlan_layer) ? 1 : 0;
 	entry.bfib1.cah = 1;
 	entry.bfib1.time_stamp = (hnat_priv->data->version == MTK_HNAT_V2 ||
@@ -1188,12 +1218,14 @@ struct foe_entry ppe_fill_info_blk(struct ethhdr *eth, struct foe_entry entry,
 }
 
 static struct ethhdr *get_ipv6_ipip_ethhdr(struct sk_buff *skb,
-					   struct flow_offload_hw_path *hw_path)
+					   //struct flow_offload_hw_path *hw_path)
+					   struct hnat_hw_path *hw_path)
 {
 	struct ethhdr *eth;
 	u16 eth_pppoe_hlen = ETH_HLEN + PPPOE_SES_HLEN;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE)
+	//if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE)
+	if (hw_path->flags & HNAT_PATH_PPPOE)
 		eth = (struct ethhdr *)(skb->data - eth_pppoe_hlen);
 	else
 		eth = (struct ethhdr *)(skb->data - ETH_HLEN);
@@ -1204,7 +1236,8 @@ static struct ethhdr *get_ipv6_ipip_ethhdr(struct sk_buff *skb,
 static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				     const struct net_device *dev,
 				     struct foe_entry *foe,
-				     struct flow_offload_hw_path *hw_path)
+				     //struct flow_offload_hw_path *hw_path)
+				     struct hnat_hw_path *hw_path)
 {
 	struct foe_entry entry = { 0 };
 	int whnat = IS_WHNAT(dev);
@@ -1318,7 +1351,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 
 				entry.ipv4_hnapt.vlan1 = hw_path->vlan_id;
 
-				if (skb_vlan_tagged(skb)) {
+				if (skb_vlan_tag_present(skb)) {
 					entry.bfib1.vlan_layer += 1;
 
 					if (entry.ipv4_hnapt.vlan1)
@@ -1372,7 +1405,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 
 			entry.ipv6_5t_route.vlan1 = hw_path->vlan_id;
 
-			if (skb_vlan_tagged(skb)) {
+			if (skb_vlan_tag_present(skb)) {
 				entry.bfib1.vlan_layer += 1;
 
 				if (entry.ipv6_5t_route.vlan1)
@@ -1660,13 +1693,13 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 		} else {
 			gmac = (IS_GMAC1_MODE) ? NR_GMAC1_PORT : NR_GMAC2_PORT;
 		}
-	} else if (IS_EXT(dev) && (FROM_GE_PPD(skb) || FROM_GE_LAN_GRP(skb) ||
+	} else if (IS_EXT(dev) && (FROM_GE_LAN_GRP(skb) || FROM_GE_PPD(skb) ||
 		   FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb) || FROM_WED(skb))) {
 		if (!hnat_priv->data->whnat && IS_GMAC1_MODE) {
 			entry.bfib1.vpm = 1;
 			entry.bfib1.vlan_layer = 1;
 
-			if (FROM_GE_LAN(skb))
+			if (FROM_GE_LAN_GRP(skb) || FROM_GE_PPD(skb))
 				entry.ipv4_hnapt.vlan1 = 1;
 			else if (FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))
 				entry.ipv4_hnapt.vlan1 = 2;
@@ -1716,12 +1749,13 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 					entry.ipv4_hnapt.iblk2.port_mg |=
 						((qid >> 4) & 0x3);
 
-				if (((IS_EXT(dev) && (FROM_GE_LAN_GRP(skb) ||
+				if (((IS_EXT(dev) && (FROM_GE_LAN_GRP(skb) || FROM_GE_PPD(skb) ||
 				      FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) ||
 				      ((mape_toggle && mape == 1) && !FROM_EXT(skb))) &&
 				      (!whnat)) {
 					entry.ipv4_hnapt.etype = htons(HQOS_MAGIC_TAG);
 					entry.ipv4_hnapt.vlan1 = skb_hnat_entry(skb);
+					entry.bfib1.vpm = 0;
 					entry.bfib1.vlan_layer = 1;
 				}
 			}
@@ -1763,11 +1797,12 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 					entry.ipv6_5t_route.iblk2.port_mg |=
 								((qid >> 4) & 0x3);
 
-				if (IS_EXT(dev) && (FROM_GE_LAN_GRP(skb) ||
+				if (IS_EXT(dev) && (FROM_GE_LAN_GRP(skb) || FROM_GE_PPD(skb) ||
 				    FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb)) &&
 				    (!whnat)) {
 					entry.ipv6_5t_route.etype = htons(HQOS_MAGIC_TAG);
 					entry.ipv6_5t_route.vlan1 = skb_hnat_entry(skb);
+					entry.bfib1.vpm = 0;
 					entry.bfib1.vlan_layer = 1;
 				}
 			}
@@ -1896,7 +1931,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 		break;
 	}
 
-	if (skb_vlan_tagged(skb)) {
+	if (skb_vlan_tag_present(skb)) {
 		bfib1_tx.vlan_layer = 1;
 		bfib1_tx.vpm = 1;
 		if (IS_IPV4_GRP(entry)) {
@@ -1949,14 +1984,15 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 				bfib1_tx.vpm = 1;
 				bfib1_tx.vlan_layer = 1;
 
-				if (FROM_GE_LAN_GRP(skb))
+				if (FROM_GE_LAN_GRP(skb) ||  FROM_GE_PPD(skb))
 					entry->ipv4_hnapt.vlan1 = 1;
 				else if (FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))
 					entry->ipv4_hnapt.vlan1 = 2;
 			}
 
 			if (IS_HQOS_MODE &&
-			    (FROM_GE_LAN_GRP(skb) || FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {
+			    (FROM_GE_LAN_GRP(skb) || FROM_GE_PPD(skb) ||
+			     FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {
 				bfib1_tx.vpm = 0;
 				bfib1_tx.vlan_layer = 1;
 				entry->ipv4_hnapt.etype = htons(HQOS_MAGIC_TAG);
@@ -2024,14 +2060,15 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 				bfib1_tx.vpm = 1;
 				bfib1_tx.vlan_layer = 1;
 
-				if (FROM_GE_LAN_GRP(skb))
+				if (FROM_GE_LAN_GRP(skb) || FROM_GE_PPD(skb))
 					entry->ipv6_5t_route.vlan1 = 1;
 				else if (FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))
 					entry->ipv6_5t_route.vlan1 = 2;
 			}
 
 			if (IS_HQOS_MODE &&
-			    (FROM_GE_LAN_GRP(skb) || FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {
+			    (FROM_GE_LAN_GRP(skb) || FROM_GE_PPD(skb) ||
+			     FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {
 				bfib1_tx.vpm = 0;
 				bfib1_tx.vlan_layer = 1;
 				entry->ipv6_5t_route.etype = htons(HQOS_MAGIC_TAG);
@@ -2080,6 +2117,15 @@ void mtk_ppe_dev_register_hook(struct net_device *dev)
 	int i, number = 0;
 	struct extdev_entry *ext_entry;
 
+	//TODO:
+	if (dev->name && !strncmp(dev->name, "wds", 3))
+		return;
+
+	if (!hnat_priv->guest_en && dev->name) {
+		if (!strcmp(dev->name, "ra1") || !strcmp(dev->name, "rai1") || !strcmp(dev->name, "rax1"))
+			return;
+	}
+
 	for (i = 1; i < MAX_IF_NUM; i++) {
 		if (hnat_priv->wifi_hook_if[i] == dev) {
 			pr_info("%s : %s has been registered in wifi_hook_if table[%d]\n",
@@ -2504,14 +2550,20 @@ int mtk_464xlat_post_process(struct sk_buff *skb, const struct net_device *out)
 static unsigned int mtk_hnat_nf_post_routing(
 	struct sk_buff *skb, const struct net_device *out,
 	unsigned int (*fn)(struct sk_buff *, const struct net_device *,
-			   struct flow_offload_hw_path *),
+			   //struct flow_offload_hw_path *),
+			   struct hnat_hw_path *),
 	const char *func)
 {
 	struct foe_entry *entry;
-	struct flow_offload_hw_path hw_path = { .dev = (struct net_device*)out,
-						.virt_dev = (struct net_device*)out };
+	/*struct flow_offload_hw_path hw_path = { .dev = (struct net_device*)out,
+						.virt_dev = (struct net_device*)out };*/
+	struct hnat_hw_path hw_path = { .real_dev = out, .virt_dev = out };
 	const struct net_device *arp_dev = out;
 
+	if (skb->protocol == htons(ETH_P_IPV6) && !hnat_priv->ipv6_en) {
+		return 0;
+	}
+
 	if (xlat_toggle && !mtk_464xlat_post_process(skb, out))
 		return 0;
 
@@ -2525,9 +2577,13 @@ static unsigned int mtk_hnat_nf_post_routing(
 	if (unlikely(!skb_hnat_is_hashed(skb)))
 		return 0;
 
-	if (out->netdev_ops->ndo_flow_offload_check) {
+	/*if (out->netdev_ops->ndo_flow_offload_check) {
 		out->netdev_ops->ndo_flow_offload_check(&hw_path);
-		out = (IS_GMAC1_MODE) ? hw_path.virt_dev : hw_path.dev;
+		out = (IS_GMAC1_MODE) ? hw_path.virt_dev : hw_path.dev;*/
+	if (out->netdev_ops->ndo_hnat_check) {
+		if (out->netdev_ops->ndo_hnat_check(&hw_path))
+			return 0;
+		out = (IS_GMAC1_MODE) ? hw_path.virt_dev : hw_path.real_dev;
 	}
 
 	if (!IS_LAN_GRP(out) && !IS_WAN(out) && !IS_EXT(out))
@@ -2572,7 +2628,8 @@ static unsigned int mtk_hnat_nf_post_routing(
 			entry->ipv4_hnapt.m_timestamp = foe_timestamp(hnat_priv);
 
 		if (entry_hnat_is_bound(entry)) {
-			memset(skb_hnat_info(skb), 0, sizeof(struct hnat_desc));
+			//memset(skb_hnat_info(skb), 0, sizeof(struct hnat_desc));
+			memset(skb_hnat_info(skb), 0, FOE_INFO_LEN);
 
 			return -1;
 		}
@@ -2834,7 +2891,11 @@ static unsigned int mtk_hnat_br_nf_forward(void *priv,
 					   struct sk_buff *skb,
 					   const struct nf_hook_state *state)
 {
-	if ((hnat_priv->data->version == MTK_HNAT_V1_2) &&
+	//if ((hnat_priv->data->version == MTK_HNAT_V1_2) &&
+	//if (unlikely(IS_EXT(state->in) && IS_EXT(state->out)))
+	if ((hnat_priv->data->version == MTK_HNAT_V1_1 ||
+	     hnat_priv->data->version == MTK_HNAT_V1_2 ||
+	     hnat_priv->data->version == MTK_HNAT_V1_3) &&
 	    unlikely(IS_EXT(state->in) && IS_EXT(state->out)))
 		hnat_set_head_frags(state, skb, 1, hnat_set_alg);
 
@@ -2900,12 +2961,20 @@ static struct nf_hook_ops mtk_hnat_nf_ops[] __read_mostly = {
 
 int hnat_register_nf_hooks(void)
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0))
+	return nf_register_hooks(mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
+#else
 	return nf_register_net_hooks(&init_net, mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
+#endif
 }
 
 void hnat_unregister_nf_hooks(void)
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0))
+	nf_unregister_hooks(mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
+#else
 	nf_unregister_net_hooks(&init_net, mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
+#endif
 }
 
 int whnat_adjust_nf_hooks(void)
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_stag.c b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_stag.c
index 75c3a75c..4e03f275 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_stag.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_stag.c
@@ -5,12 +5,14 @@
  */
 
 #include <linux/of_device.h>
-#include <net/netfilter/nf_flow_table.h>
+//#include <net/netfilter/nf_flow_table.h>
+#include <net/netfilter/nf_hnat.h>
 #include "hnat.h"
 
 u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 		       struct foe_entry *entry,
-		       struct flow_offload_hw_path *hw_path,
+		       //struct flow_offload_hw_path *hw_path,
+		       struct hnat_hw_path *hw_path,
 		       u16 eth_proto,
 		       int mape)
 {
@@ -19,8 +21,10 @@ u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 	int port_index;
 	u16 sp_tag;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN)
-		ndev = hw_path->dev;
+	/*if (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN)
+		ndev = hw_path->dev;*/
+	if (hw_path->flags & HNAT_PATH_VLAN)
+		ndev = hw_path->real_dev;
 	else
 		ndev = netdev;
 
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/nf_hnat_mtk.h b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/nf_hnat_mtk.h
index 800c8213..357c6ba0 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/nf_hnat_mtk.h
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/nf_hnat_mtk.h
@@ -16,7 +16,7 @@
 
 #include <linux/dma-mapping.h>
 #include <linux/netdevice.h>
-#include "../mtk_eth_soc.h"
+//#include "../mtk_eth_soc.h"
 
 #define HNAT_SKB_CB2(__skb) ((struct hnat_skb_cb2 *)&((__skb)->cb[44]))
 struct hnat_skb_cb2 {
@@ -69,14 +69,19 @@ struct hnat_desc {
 	u32 entry : 14;
 	u32 crsn : 5;
 	u32 sport : 4;
+	/*u32 sport : 3;
+	u32 rev : 1;*/
 	u32 alg : 1;
-	u32 iface : 8;
+	/*u32 iface : 8;
 	u32 filled : 3;
-	u32 resv : 1;
+	u32 resv : 1;*/
+	u32 iface : 7;
+	u32 filled : 1;
 	u32 magic_tag_protect : 16;
 	u32 wdmaid : 8;
 	u32 rxid : 2;
-	u32 wcid : 10;
+	/*u32 wcid : 10;*/
+	u32 wcid : 8;
 	u32 bssid : 6;
 } __packed;
 #endif
@@ -85,8 +90,8 @@ struct hnat_desc {
 #define HAS_HQOS_MAGIC_TAG(skb) (qos_toggle && skb->protocol == HQOS_MAGIC_TAG)
 
 #define HNAT_MAGIC_TAG 0x6789
-#define WIFI_INFO_LEN 6
-#define FOE_INFO_LEN (10 + WIFI_INFO_LEN)
+#define WIFI_INFO_LEN 0
+#define FOE_INFO_LEN (6 + WIFI_INFO_LEN)
 #define IS_SPACE_AVAILABLE_HEAD(skb)                                           \
 	((((skb_headroom(skb) >= FOE_INFO_LEN) ? 1 : 0)))
 
@@ -134,6 +139,7 @@ struct hnat_desc {
 #define set_from_extge(skb) (HNAT_SKB_CB2(skb)->magic = 0x78786688)
 #define clr_from_extge(skb) (HNAT_SKB_CB2(skb)->magic = 0x0)
 #define set_to_ppe(skb) (HNAT_SKB_CB2(skb)->magic = 0x78681415)
+#define is_to_ppe(skb) (HNAT_SKB_CB2(skb)->magic == 0x78681415)
 #define is_from_extge(skb) (HNAT_SKB_CB2(skb)->magic == 0x78786688)
 #define is_magic_tag_valid(skb) (skb_hnat_magic_tag(skb) == HNAT_MAGIC_TAG)
 #define set_from_mape(skb) (HNAT_SKB_CB2(skb)->magic = 0x78787788)
-- 
2.32.0.windows.2

