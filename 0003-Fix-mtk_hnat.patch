From 02c4b07ab2b40c30a66ea77987ad9d1dc4473dd6 Mon Sep 17 00:00:00 2001
From: lyh802 <lyh802@126.com>
Date: Wed, 14 Jun 2023 00:22:38 +0800
Subject: [PATCH 3/5] Fix mtk_hnat

---
 .../net/ethernet/mediatek/mtk_hnat/Makefile   |   5 +-
 .../net/ethernet/mediatek/mtk_hnat/hnat.c     |  50 ++-
 .../net/ethernet/mediatek/mtk_hnat/hnat.h     |  37 ++-
 .../ethernet/mediatek/mtk_hnat/hnat_debugfs.c |  95 +++++-
 .../ethernet/mediatek/mtk_hnat/hnat_mcast.c   |  13 +-
 .../ethernet/mediatek/mtk_hnat/hnat_nf_hook.c | 305 ++++++++++++++++--
 .../ethernet/mediatek/mtk_hnat/hnat_stag.c    |  14 +-
 .../ethernet/mediatek/mtk_hnat/nf_hnat_mtk.h  |   8 +-
 .../net/ethernet/raeth/mtk_hnat/Makefile      |   5 +-
 .../net/ethernet/raeth/mtk_hnat/hnat.c        |  50 ++-
 .../net/ethernet/raeth/mtk_hnat/hnat.h        |  37 ++-
 .../ethernet/raeth/mtk_hnat/hnat_debugfs.c    |  95 +++++-
 .../net/ethernet/raeth/mtk_hnat/hnat_mcast.c  |  13 +-
 .../ethernet/raeth/mtk_hnat/hnat_nf_hook.c    | 305 ++++++++++++++++--
 .../net/ethernet/raeth/mtk_hnat/hnat_stag.c   |  14 +-
 .../net/ethernet/raeth/mtk_hnat/nf_hnat_mtk.h |   8 +-
 16 files changed, 920 insertions(+), 134 deletions(-)

diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/Makefile b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/Makefile
index bf1bbcbc..1bbd891b 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/Makefile
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/Makefile
@@ -1,5 +1,4 @@
 ccflags-y=-Werror
 
-obj-$(CONFIG_NET_MEDIATEK_HNAT)         += mtkhnat.o
-mtkhnat-objs := hnat.o hnat_nf_hook.o hnat_debugfs.o hnat_mcast.o
-mtkhnat-$(CONFIG_NET_DSA_MT7530)	+= hnat_stag.o
+obj-m         += hw_nat.o
+hw_nat-objs := hnat.o hnat_nf_hook.o hnat_debugfs.o hnat_mcast.o
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat.c b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat.c
index 7cda69f0..66771200 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat.c
@@ -42,7 +42,8 @@ EXPORT_SYMBOL(ppe_dev_register_hook);
 void (*ppe_dev_unregister_hook)(struct net_device *dev) = NULL;
 EXPORT_SYMBOL(ppe_dev_unregister_hook);
 
-static void hnat_sma_build_entry(struct timer_list *t)
+static void hnat_sma_build_entry(unsigned long data)
+//static void hnat_sma_build_entry(struct timer_list *t)
 {
 	int i;
 
@@ -62,7 +63,8 @@ void hnat_cache_ebl(int enable)
 	}
 }
 
-static void hnat_reset_timestamp(struct timer_list *t)
+static void hnat_reset_timestamp(unsigned long data)
+//static void hnat_reset_timestamp(struct timer_list *t)
 {
 	struct foe_entry *entry;
 	int hash_index;
@@ -218,6 +220,7 @@ int entry_delete_by_mac(u8 *mac)
 
 	return ret;
 }
+//TODO:EXPORT_SYMBOL(entry_delete_by_mac);
 
 static void hnat_roam_handler(struct work_struct *work)
 {
@@ -328,6 +331,7 @@ static int hnat_hw_init(u32 ppe_id)
 
 	/* enable FOE */
 	cr_set_bits(hnat_priv->ppe_base[ppe_id] + PPE_FLOW_CFG,
+		    //FIXME:BIT_UDP_IP4F_NAT_EN | BIT_IPV4_NAT_EN | BIT_IPV4_NAPT_EN |
 		    BIT_IPV4_NAT_EN | BIT_IPV4_NAPT_EN |
 		    BIT_IPV4_NAT_FRAG_EN | BIT_IPV4_HASH_GREK |
 		    BIT_IPV4_DSL_EN | BIT_IPV6_6RD_EN |
@@ -357,6 +361,7 @@ static int hnat_hw_init(u32 ppe_id)
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_BND_AGE_1, TCP_DLTA, 7);
 
 	/* setup FOE ka */
+	//FIXME:
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, KA_CFG, 0);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_BIND_LMT_1, NTU_KA, 0);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_KA, KA_T, 0);
@@ -366,6 +371,7 @@ static int hnat_hw_init(u32 ppe_id)
 
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, SCAN_MODE, 2);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, KA_CFG, 3);
+	//FIXME:
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, TICK_SEL, 0);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_KA, KA_T, 1);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_KA, TCP_KA, 1);
@@ -384,6 +390,7 @@ static int hnat_hw_init(u32 ppe_id)
 	writel(0, hnat_priv->ppe_base[ppe_id] + PPE_DFT_CPORT); /* pdma */
 	/* writel(0x55555555, hnat_priv->ppe_base[ppe_id] + PPE_DFT_CPORT); */ /* qdma */
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_GLO_CFG, TTL0_DRP, 0);
+	//FIXME:
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_GLO_CFG, MCAST_TB_EN, 1);
 
 	if (hnat_priv->data->version == MTK_HNAT_V2 ||
@@ -482,6 +489,7 @@ static int ppe_busy_wait(u32 ppe_id)
 			return 0;
 		if (time_after(jiffies, t_start + HZ))
 			break;
+		//usleep_range(10, 20);
 		mdelay(10);
 	}
 
@@ -495,6 +503,8 @@ static void hnat_stop(u32 ppe_id)
 	u32 foe_table_sz;
 	u32 foe_mib_tb_sz;
 	struct foe_entry *entry, *end;
+	u32 r1 = 0, r2 = 0;
+	//TODO:
 
 	if (ppe_id >= CFG_PPE_NUM)
 		return;
@@ -550,6 +560,18 @@ static void hnat_stop(u32 ppe_id)
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, UDP_AGE, 0);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, FIN_AGE, 0);
 
+	r1 = readl(hnat_priv->fe_base + 0x100);
+	r2 = readl(hnat_priv->fe_base + 0x10c);
+
+	dev_info(hnat_priv->dev, "0x100 = 0x%x, 0x10c = 0x%x\n", r1, r2);
+
+	if (((r1 & 0xff00) >> 0x8) >= (r1 & 0xff) ||
+	    ((r1 & 0xff00) >> 0x8) >= (r2 & 0xff)) {
+		dev_info(hnat_priv->dev, "reset pse\n");
+		writel(0x1, hnat_priv->fe_base + 0x4);
+	}
+	//TODO:
+
 	/* free the FOE table */
 	foe_table_sz = hnat_priv->foe_etry_num * sizeof(struct foe_entry);
 	if (hnat_priv->foe_table_cpu[ppe_id])
@@ -602,6 +624,7 @@ int hnat_enable_hook(void)
 {
 	/* register hook functions used by WHNAT module.
 	 */
+	//if (hnat_priv->data->version == MTK_HNAT_V1_2) {
 	if (hnat_priv->data->whnat) {
 		ra_sw_nat_hook_rx =
 			(hnat_priv->data->version == MTK_HNAT_V2 ||
@@ -732,21 +755,21 @@ static int hnat_probe(struct platform_device *pdev)
 
 	err = of_property_read_string(np, "mtketh-lan", &name);
 	if (err < 0)
-		strncpy(hnat_priv->lan, "eth0", IFNAMSIZ);
+		strncpy(hnat_priv->lan, "eth2", IFNAMSIZ);
 	else
 		strncpy(hnat_priv->lan, (char *)name, IFNAMSIZ - 1);
 	dev_info(&pdev->dev, "lan = %s\n", hnat_priv->lan);
 
 	err = of_property_read_string(np, "mtketh-lan2", &name);
 	if (err < 0)
-		strncpy(hnat_priv->lan2, "eth2", IFNAMSIZ);
+		strncpy(hnat_priv->lan2, "eth4", IFNAMSIZ);
 	else
 		strncpy(hnat_priv->lan2, (char *)name, IFNAMSIZ - 1);
 	dev_info(&pdev->dev, "lan2 = %s\n", hnat_priv->lan2);
 
 	err = of_property_read_string(np, "mtketh-ppd", &name);
 	if (err < 0)
-		strncpy(hnat_priv->ppd, "eth0", IFNAMSIZ);
+		strncpy(hnat_priv->ppd, "eth2", IFNAMSIZ);
 	else
 		strncpy(hnat_priv->ppd, (char *)name, IFNAMSIZ - 1);
 	dev_info(&pdev->dev, "ppd = %s\n", hnat_priv->ppd);
@@ -783,6 +806,7 @@ static int hnat_probe(struct platform_device *pdev)
 	if (!res)
 		return -ENOENT;
 
+	//hnat_priv->fe_base = devm_ioremap(&pdev->dev, res->start,
 	hnat_priv->fe_base = devm_ioremap_nocache(&pdev->dev, res->start,
 					     res->end - res->start + 1);
 	if (!hnat_priv->fe_base)
@@ -800,6 +824,9 @@ static int hnat_probe(struct platform_device *pdev)
 	hnat_priv->ppe_base[0] = hnat_priv->fe_base + 0xe00;
 #endif
 
+	//hnat_priv->ipv6_en = true; /* enable ipv6 by default */
+	//hnat_priv->guest_en = true; /* enable guest wifi by default */
+
 	err = hnat_init_debugfs(hnat_priv);
 	if (err)
 		return err;
@@ -848,16 +875,22 @@ static int hnat_probe(struct platform_device *pdev)
 			hnat_mcast_enable(i);
 	}
 
-	timer_setup(&hnat_priv->hnat_sma_build_entry_timer, hnat_sma_build_entry, 0);
+	init_timer(&hnat_priv->hnat_sma_build_entry_timer);
+	hnat_priv->hnat_sma_build_entry_timer.function = hnat_sma_build_entry;
+	//timer_setup(&hnat_priv->hnat_sma_build_entry_timer, hnat_sma_build_entry, 0);
 	if (hnat_priv->data->version == MTK_HNAT_V1_3) {
-		timer_setup(&hnat_priv->hnat_reset_timestamp_timer, hnat_reset_timestamp, 0);
+		init_timer(&hnat_priv->hnat_reset_timestamp_timer);
+		hnat_priv->hnat_reset_timestamp_timer.function = hnat_reset_timestamp;
+		//timer_setup(&hnat_priv->hnat_reset_timestamp_timer, hnat_reset_timestamp, 0);
 		hnat_priv->hnat_reset_timestamp_timer.expires = jiffies;
 		add_timer(&hnat_priv->hnat_reset_timestamp_timer);
 	}
 
+	//if (qos_toggle && IS_GMAC1_MODE)
 	if (IS_HQOS_MODE && IS_GMAC1_MODE)
 		dev_add_pack(&mtk_pack_type);
 
+	//FIXME:
 	err = hnat_roaming_enable();
 	if (err)
 		pr_info("hnat roaming work fail\n");
@@ -883,6 +916,7 @@ static int hnat_remove(struct platform_device *pdev)
 {
 	int i;
 
+	//FIXME:
 	hnat_roaming_disable();
 	unregister_netdevice_notifier(&nf_hnat_netdevice_nb);
 	unregister_netevent_notifier(&nf_hnat_netevent_nb);
@@ -900,6 +934,7 @@ static int hnat_remove(struct platform_device *pdev)
 	if (hnat_priv->data->version == MTK_HNAT_V1_3)
 		del_timer_sync(&hnat_priv->hnat_reset_timestamp_timer);
 
+	//if (qos_toggle && IS_GMAC1_MODE)
 	if (IS_HQOS_MODE && IS_GMAC1_MODE)
 		dev_remove_pack(&mtk_pack_type);
 
@@ -909,6 +944,7 @@ static int hnat_remove(struct platform_device *pdev)
 static const struct mtk_hnat_data hnat_data_v1 = {
 	.num_of_sch = 2,
 	.whnat = false,
+	//TODO:.whnat = true,
 	.per_flow_accounting = false,
 	.mcast = false,
 	.version = MTK_HNAT_V1_1,
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat.h b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat.h
index 8f5f37b3..0a74791e 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat.h
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat.h
@@ -16,7 +16,8 @@
 #include <linux/if.h>
 #include <linux/if_ether.h>
 #include <net/netevent.h>
-#include <linux/mod_devicetable.h>
+#include <net/netfilter/nf_hnat.h>
+//#include <linux/mod_devicetable.h>
 #include "hnat_mcast.h"
 #include "nf_hnat_mtk.h"
 
@@ -109,6 +110,11 @@
 #define GDMA3_FWD_CFG 0x540
 
 /* QDMA Tx queue configuration */
+#if defined(CONFIG_MEDIATEK_NETSYS_V2)
+#define QDMA_BASE               0x4400
+#else
+#define QDMA_BASE               0x1800
+#endif
 #define QTX_CFG(x)			(QDMA_BASE + ((x) * 0x10))
 #define QTX_CFG_HW_RESV_CNT_OFFSET	(8)
 #define QTX_CFG_SW_RESV_CNT_OFFSET	(0)
@@ -556,6 +562,7 @@ struct hnat_ipv6_3t_route {
 	u32 ipv6_dip2;
 	u32 ipv6_dip3;
 	u32 prot : 8;
+	//u32 resv : 24;
 	u32 hph : 24; /* hash placeholder */
 
 	u32 resv1;
@@ -802,8 +809,10 @@ struct foe_entry {
 /* If user wants to change default FOE entry number, both DEF_ETRY_NUM and
  * DEF_ETRY_NUM_CFG need to be modified.
  */
+//#define DEF_ETRY_NUM		16384
 #define DEF_ETRY_NUM		8192
 /* feasible values : 32768, 16384, 8192, 4096, 2048, 1024 */
+//#define DEF_ETRY_NUM_CFG	TABLE_16K
 #define DEF_ETRY_NUM_CFG	TABLE_8K
 /* corresponding values : TABLE_32K, TABLE_16K, TABLE_8K, TABLE_4K, TABLE_2K,
  * TABLE_1K
@@ -904,6 +913,8 @@ struct mtk_hnat {
 	struct timer_list hnat_mcast_check_timer;
 	bool nf_stat_en;
 	struct xlat_conf xlat;
+	//bool ipv6_en;
+	//bool guest_en;
 };
 
 struct extdev_entry {
@@ -925,8 +936,13 @@ enum FoeIpAct {
 	IPV6_3T_ROUTE = 4,
 	IPV6_5T_ROUTE = 5,
 	IPV6_6RD = 7,
+//TODO:#if defined(CONFIG_MEDIATEK_NETSYS_V2) || defined(CONFIG_MEDIATEK_NETSYS_V3)
 	IPV4_MAP_T = 8,
 	IPV4_MAP_E = 9,
+/*#else
+	IPV4_MAP_T = 6,
+	IPV4_MAP_E = 6,
+#endif*/
 	IPV6_HNAPT = 10,
 	IPV6_HNAT = 11,
 };
@@ -942,6 +958,7 @@ enum FoeIpAct {
 #define ENTRY_128B 0
 #define ENTRY_96B 1
 #define ENTRY_80B 1
+#define ENTRY_64B 0
 #define TABLE_1K 0
 #define TABLE_2K 1
 #define TABLE_4K 2
@@ -961,6 +978,7 @@ enum FoeIpAct {
 #define BIT_FUC_FOE BIT(2)
 #define BIT_FMC_FOE BIT(1)
 #define BIT_FBC_FOE BIT(0)
+#define BIT_TCP_IP4F_NAT_EN BIT(6)
 #define BIT_UDP_IP4F_NAT_EN BIT(7) /*Enable IPv4 fragment + UDP packet NAT*/
 #define BIT_IPV6_3T_ROUTE_EN BIT(8)
 #define BIT_IPV6_5T_ROUTE_EN BIT(9)
@@ -1094,6 +1112,8 @@ enum FoeIpAct {
 #define IS_LAN2(dev) (!strncmp(dev->name, LAN2_DEV_NAME,			\
 		      strlen(LAN2_DEV_NAME)))
 #define IS_BR(dev) (!strncmp(dev->name, "br", 2))
+/*#define IS_WHNAT(dev)							       \
+	((hnat_priv->data->version == MTK_HNAT_V1_2 &&			       \*/
 #define IS_WHNAT(dev)								\
 	((hnat_priv->data->whnat &&						\
 	 (get_wifi_hook_if_index_from_dev(dev) != 0)) ? 1 : 0)
@@ -1114,6 +1134,7 @@ enum FoeIpAct {
 	(IS_IPV6_3T_ROUTE(x) | IS_IPV6_5T_ROUTE(x) | IS_IPV6_6RD(x) |          \
 	 IS_IPV4_DSLITE(x) | IS_IPV4_MAPE(x) | IS_IPV4_MAPT(x) |	       \
 	 IS_IPV6_HNAPT(x) | IS_IPV6_HNAT(x))
+//FIXME:	 IS_IPV4_DSLITE(x))
 #define IS_BOND_MODE (!strncmp(LAN_DEV_NAME, "bond", 4))
 #define IS_GMAC1_MODE ((hnat_priv->gmac_num == 1) ? 1 : 0)
 #define IS_HQOS_MODE (qos_toggle == 1)
@@ -1171,7 +1192,10 @@ extern struct mtk_hnat *hnat_priv;
 #if defined(CONFIG_NET_DSA_MT7530)
 u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 		       struct foe_entry *entry,
-		       struct flow_offload_hw_path *hw_path,
+		       struct hnat_hw_path *hw_path,
+		       //struct net_device_path_ctx *ctx,
+		       //struct net_device_path *hw_path,
+		       //struct flow_offload_hw_path *hw_path,
 		       u16 eth_proto, int mape);
 
 static inline bool hnat_dsa_is_enable(struct mtk_hnat *priv)
@@ -1181,7 +1205,10 @@ static inline bool hnat_dsa_is_enable(struct mtk_hnat *priv)
 #else
 static inline u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 				     struct foe_entry *entry,
-				     struct flow_offload_hw_path *hw_path,
+				     struct hnat_hw_path *hw_path,
+				     //struct net_device_path_ctx *ctx,
+				     //struct net_device_path *hw_path,
+				     //struct flow_offload_hw_path *hw_path,
 				     u16 eth_proto, int mape)
 {
 	return 0;
@@ -1194,6 +1221,7 @@ static inline bool hnat_dsa_is_enable(struct mtk_hnat *priv)
 #endif
 
 void hnat_deinit_debugfs(struct mtk_hnat *h);
+//int __init hnat_init_debugfs(struct mtk_hnat *h);
 int hnat_init_debugfs(struct mtk_hnat *h);
 int hnat_register_nf_hooks(void);
 void hnat_unregister_nf_hooks(void);
@@ -1230,7 +1258,8 @@ void hnat_qos_shaper_ebl(u32 id, u32 enable);
 void set_gmac_ppe_fwd(int gmac_no, int enable);
 int entry_detail(u32 ppe_id, int index);
 int entry_delete_by_mac(u8 *mac);
-int entry_delete(u32 ppe_id, int index);
+int entry_delete(int index);
+//TODO:int entry_delete(u32 ppe_id, int index);
 int hnat_warm_init(void);
 u32 hnat_get_ppe_hash(struct foe_entry *entry);
 int mtk_ppe_get_xlat_v4_by_v6(struct in6_addr *ipv6, u32 *ipv4);
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_debugfs.c b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_debugfs.c
index 96d446e7..f1e2ef00 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_debugfs.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_debugfs.c
@@ -371,6 +371,7 @@ int entry_detail(u32 ppe_id, int index)
 	pr_info("==========<PPE_ID=%d, Flow Table Entry=%d (%p)>===============\n",
 		ppe_id, index, entry);
 	if (debug_level >= 2) {
+		//print_cnt = 32;
 		print_cnt = 20;
 		for (i = 0; i < print_cnt; i++)
 			pr_info("%02d: %08X\n", i, *(p + i));
@@ -630,19 +631,22 @@ int entry_detail(u32 ppe_id, int index)
 }
 
 int wrapped_ppe0_entry_delete(int index) {
-	entry_delete(0, index);
+	entry_delete(index);
+	//TODO:entry_delete(0, index);
 	return 0;
 }
 
 int wrapped_ppe1_entry_delete(int index) {
-	entry_delete(1, index);
+	//TODO:entry_delete(1, index);
 	return 0;
 }
 
-int entry_delete(u32 ppe_id, int index)
+int entry_delete(int index)
+//TODO:int entry_delete(u32 ppe_id, int index)
 {
 	struct foe_entry *entry;
 	struct mtk_hnat *h = hnat_priv;
+	u32 ppe_id = 0;
 
 	if (ppe_id >= CFG_PPE_NUM)
 		return -EINVAL;
@@ -684,7 +688,9 @@ int cr_set_usage(int level)
 	pr_info("              4     0~65535    Set UDP bind lifetime\n");
 	pr_info("              5     0~255      Set TCP keep alive interval\n");
 	pr_info("              6     0~255      Set UDP keep alive interval\n");
-	pr_info("              7     0~1        Set hnat counter update to nf_conntrack\n");
+	pr_info("              8     0~1        Set hnat counter update to nf_conntrack\n");
+	pr_info("              7     0~1        Set hnat disable/enable ipv6\n");
+	pr_info("              9     0~1        Set hnat disable/enable guest (rax1/rai1/ra1)\n");
 
 	return 0;
 }
@@ -796,6 +802,57 @@ int set_nf_update_toggle(int toggle)
 	return 0;
 }
 
+int set_ipv6_toggle(int toggle)
+{
+	struct mtk_hnat *h = hnat_priv;
+
+	if (toggle == 1)
+		pr_info("Enable hnat ipv6\n");
+	else if (toggle == 0)
+		pr_info("Disable hnat ipv6\n");
+	else {
+		pr_info("input error, current ipv6_en=%d\n", h->ipv6_en);
+		return 0;
+	}
+	h->ipv6_en = toggle;
+
+	return 0;
+}
+
+void mtk_ppe_dev_hook(const char *name, int toggle)
+{
+	struct net_device *dev;
+	dev = dev_get_by_name(&init_net, name);
+	if (dev) {
+		if (toggle) {
+			mtk_ppe_dev_register_hook(dev);
+		} else {
+			mtk_ppe_dev_unregister_hook(dev);
+		}
+	}
+	return;
+}
+
+int set_guest_toggle(int toggle)
+{
+	struct mtk_hnat *h = hnat_priv;
+
+	if (toggle == 1)
+		pr_info("Enable hnat guest interface\n");
+	else if (toggle == 0)
+		pr_info("Disable hnat guest interface\n");
+	else {
+		pr_info("input error, current guest_en=%d\n", h->guest_en);
+		return 0;
+	}
+	h->guest_en = toggle;
+
+	mtk_ppe_dev_hook("ra1", toggle);
+	mtk_ppe_dev_hook("rai1", toggle);
+	mtk_ppe_dev_hook("rax1", toggle);
+	return 0;
+}
+
 static const debugfs_write_func hnat_set_func[] = {
 	[0] = hnat_set_usage,
 	[1] = hnat_cpu_reason,
@@ -814,7 +871,8 @@ static const debugfs_write_func cr_set_func[] = {
 	[0] = cr_set_usage,      [1] = binding_threshold,
 	[2] = tcp_bind_lifetime, [3] = fin_bind_lifetime,
 	[4] = udp_bind_lifetime, [5] = tcp_keep_alive,
-	[6] = udp_keep_alive,    [7] = set_nf_update_toggle,
+	[6] = udp_keep_alive,    [8] = set_nf_update_toggle,
+	[7] = set_ipv6_toggle,   [9] = set_guest_toggle,
 };
 
 int read_mib(struct mtk_hnat *h, u32 ppe_id,
@@ -880,7 +938,7 @@ struct hnat_accounting *hnat_get_count(struct mtk_hnat *h, u32 ppe_id,
 
 	return &h->acct[ppe_id][index];
 }
-EXPORT_SYMBOL(hnat_get_count);
+//TODO:EXPORT_SYMBOL(hnat_get_count);
 
 #define PRINT_COUNT(m, acct) {if (acct) \
 		seq_printf(m, "bytes=%llu|packets=%llu|", \
@@ -1323,6 +1381,7 @@ static ssize_t hnat_whnat_write(struct file *file, const char __user *buf,
 			mtk_ppe_dev_unregister_hook(dev);
 			pr_info("unregister wifi extern if = %s\n", dev->name);
 		}
+		//FIXME:
 		dev_put(dev);
 	} else {
 		pr_info("no such device!\n");
@@ -1339,6 +1398,7 @@ static const struct file_operations hnat_whnat_fops = {
 	.open = hnat_whnat_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
+	//FIXME:
 	.write = hnat_whnat_write,
 	.release = single_release,
 };
@@ -1823,6 +1883,8 @@ ssize_t hnat_setting_write(struct file *file, const char __user *buffer,
 	case 5:
 	case 6:
 	case 7:
+	case 8:
+	case 9:
 		p_token = strsep(&p_buf, p_delimiter);
 		if (!p_token)
 			arg1 = 0;
@@ -2176,6 +2238,7 @@ static ssize_t hnat_queue_write(struct file *file, const char __user *buf,
 	u32 qtx_sch = 0;
 
 	cr_set_field(h->fe_base + QDMA_PAGE, QTX_CFG_PAGE, (id / NUM_OF_Q_PER_PAGE));
+	//FIXME:qtx_sch = readl(h->fe_base + QTX_SCH(id % NUM_OF_Q_PER_PAGE));
 	if (length >= sizeof(line))
 		return -EINVAL;
 
@@ -2207,6 +2270,7 @@ static ssize_t hnat_queue_write(struct file *file, const char __user *buf,
 		min_exp++;
 	}
 
+	//FIXME:qtx_sch &= 0x70000000;
 	if (hnat_priv->data->num_of_sch == 4)
 		qtx_sch |= (scheduler & 0x3) << 30;
 	else
@@ -2678,16 +2742,23 @@ static void hnat_qos_disable(void)
 
 	for (id = 0; id < MAX_PPPQ_PORT_NUM; id++) {
 		hnat_qos_shaper_ebl(id, 0);
+		//writel(0, h->fe_base + QTX_CFG(id % NUM_OF_Q_PER_PAGE));
 		writel((4 << QTX_CFG_HW_RESV_CNT_OFFSET) |
 		       (4 << QTX_CFG_SW_RESV_CNT_OFFSET),
 		       h->fe_base + QTX_CFG(id % NUM_OF_Q_PER_PAGE));
 	}
 
+	/*writel((4 << QTX_CFG_HW_RESV_CNT_OFFSET) |
+	       (4 << QTX_CFG_SW_RESV_CNT_OFFSET), h->fe_base + QTX_CFG(0));*/
+
+	//FIXME:
 	cfg = (QDMA_TX_SCH_WFQ_EN) | (QDMA_TX_SCH_WFQ_EN << 16);
 	for (id = 0; id < h->data->num_of_sch; id += 2) {
 		if (h->data->num_of_sch == 4)
+			//writel(0, h->fe_base + QDMA_TX_4SCH_BASE(id));
 			writel(cfg, h->fe_base + QDMA_TX_4SCH_BASE(id));
 		else
+			//writel(0, h->fe_base + QDMA_TX_2SCH_BASE);
 			writel(cfg, h->fe_base + QDMA_TX_2SCH_BASE);
 	}
 }
@@ -2708,11 +2779,14 @@ static void hnat_qos_pppq_enable(void)
 		       h->fe_base + QTX_CFG(id % NUM_OF_Q_PER_PAGE));
 	}
 
+	//TODO:
 	cfg = (QDMA_TX_SCH_WFQ_EN) | (QDMA_TX_SCH_WFQ_EN << 16);
 	for (id = 0; id < h->data->num_of_sch; id+= 2) {
 		if (h->data->num_of_sch == 4)
+                        //writel(0, h->fe_base + QDMA_TX_4SCH_BASE(id));
                         writel(cfg, h->fe_base + QDMA_TX_4SCH_BASE(id));
                 else
+                        //writel(0, h->fe_base + QDMA_TX_2SCH_BASE);
                         writel(cfg, h->fe_base + QDMA_TX_2SCH_BASE);
 	}
 }
@@ -3016,11 +3090,13 @@ static const struct file_operations hnat_static_fops = {
 	.release = single_release,
 };
 
-int get_ppe_mib(u32 ppe_id, int index, u64 *pkt_cnt, u64 *byte_cnt)
+int get_ppe_mib(int index, u64 *pkt_cnt, u64 *byte_cnt)
+//TODO:int get_ppe_mib(u32 ppe_id, int index, u64 *pkt_cnt, u64 *byte_cnt)
 {
 	struct mtk_hnat *h = hnat_priv;
 	struct hnat_accounting *acct;
 	struct foe_entry *entry;
+	u32 ppe_id = 0;
 
 	if (ppe_id >= CFG_PPE_NUM)
 		return -EINVAL;
@@ -3046,10 +3122,12 @@ int get_ppe_mib(u32 ppe_id, int index, u64 *pkt_cnt, u64 *byte_cnt)
 }
 EXPORT_SYMBOL(get_ppe_mib);
 
-int is_entry_binding(u32 ppe_id, int index)
+int is_entry_binding(int index)
+//TODO:int is_entry_binding(u32 ppe_id, int index)
 {
 	struct mtk_hnat *h = hnat_priv;
 	struct foe_entry *entry;
+	u32 ppe_id = 0;
 
 	if (ppe_id >= CFG_PPE_NUM)
 		return -EINVAL;
@@ -3137,6 +3215,7 @@ int hnat_init_debugfs(struct mtk_hnat *h)
 			ret = -ENOMEM;
 			goto err1;
 		}
+		//file = debugfs_create_regset32("regdump", S_IRUGO, root, h->regset);
 		file = debugfs_create_regset32(name, 0444,
 					       root, h->regset[i]);
 		if (!file) {
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_mcast.c b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_mcast.c
index edf17cb4..5dc2813e 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_mcast.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_mcast.c
@@ -256,7 +256,8 @@ out:
 	return NULL;
 }
 
-static void hnat_mcast_check_timestamp(struct timer_list *t)
+static void hnat_mcast_check_timestamp(unsigned long data)
+//static void hnat_mcast_check_timestamp(struct timer_list *t)
 {
 	struct foe_entry *entry;
 	int i, hash_index;
@@ -271,7 +272,8 @@ static void hnat_mcast_check_timestamp(struct timer_list *t)
 				if ((foe_ts - e_ts) > 0x3000)
 					foe_ts = (~(foe_ts)) & 0xffff;
 				if (abs(foe_ts - e_ts) > 20)
-					entry_delete(i, hash_index);
+					entry_delete(hash_index);
+					//TODO:entry_delete(i, hash_index);
 			}
 		}
 	}
@@ -307,8 +309,11 @@ int hnat_mcast_enable(u32 ppe_id)
 
 	/* mt7629 should checkout mcast entry life time manualy */
 	if (hnat_priv->data->version == MTK_HNAT_V1_3) {
-		timer_setup(&hnat_priv->hnat_mcast_check_timer,
-			    hnat_mcast_check_timestamp, 0);
+		init_timer(&hnat_priv->hnat_mcast_check_timer);
+		hnat_priv->hnat_mcast_check_timer.function =
+			hnat_mcast_check_timestamp;
+		/*timer_setup(&hnat_priv->hnat_mcast_check_timer,
+			    hnat_mcast_check_timestamp, 0);*/
 		hnat_priv->hnat_mcast_check_timer.expires = jiffies;
 		add_timer(&hnat_priv->hnat_mcast_check_timer);
 	}
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_nf_hook.c b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_nf_hook.c
index 05f49558..af01600d 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_nf_hook.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_nf_hook.c
@@ -14,10 +14,11 @@
 #include <linux/netfilter_bridge.h>
 #include <linux/netfilter_ipv6.h>
 
+#include <linux/of.h>
 #include <net/arp.h>
 #include <net/neighbour.h>
 #include <net/netfilter/nf_conntrack_helper.h>
-#include <net/netfilter/nf_flow_table.h>
+//#include <net/netfilter/nf_flow_table.h>
 #include <net/ipv6.h>
 #include <net/ip6_route.h>
 #include <net/ip.h>
@@ -30,7 +31,7 @@
 #include "hnat.h"
 
 #include "../mtk_eth_soc.h"
-#include "../mtk_eth_reset.h"
+//#include "../mtk_eth_reset.h"
 
 #define do_ge2ext_fast(dev, skb)                                               \
 	((IS_LAN_GRP(dev) || IS_WAN(dev) || IS_PPD(dev)) && \
@@ -191,7 +192,8 @@ void foe_clear_all_bind_entries(struct net_device *dev)
 
 	if (!IS_LAN_GRP(dev) && !IS_WAN(dev) &&
 	    !find_extif_from_devname(dev->name) &&
-	    !dev->netdev_ops->ndo_flow_offload_check)
+	    !dev->netdev_ops->ndo_hnat_check)
+	    //!dev->netdev_ops->ndo_flow_offload_check)
 		return;
 
 	for (i = 0; i < CFG_PPE_NUM; i++) {
@@ -233,6 +235,11 @@ int nf_hnat_netdevice_event(struct notifier_block *unused, unsigned long event,
 
 	switch (event) {
 	case NETDEV_UP:
+		/*TODO:if (!hnat_priv->guest_en && dev->name) {
+			if (!strcmp(dev->name, "ra1") || !strcmp(dev->name, "rai1") || !strcmp(dev->name, "rax1"))
+				break;
+		}*/
+
 		gmac_ppe_fwd_enable(dev);
 
 		extif_set_dev(dev);
@@ -246,10 +253,12 @@ int nf_hnat_netdevice_event(struct notifier_block *unused, unsigned long event,
 
 		break;
 	case NETDEV_UNREGISTER:
+		//if (IS_PPD(dev) && hnat_priv->g_ppdev) {
 		if (hnat_priv->g_ppdev == dev) {
 			hnat_priv->g_ppdev = NULL;
 			dev_put(dev);
 		}
+		//if (IS_WAN(dev) && hnat_priv->g_wandev) {
 		if (hnat_priv->g_wandev == dev) {
 			hnat_priv->g_wandev = NULL;
 			dev_put(dev);
@@ -263,10 +272,10 @@ int nf_hnat_netdevice_event(struct notifier_block *unused, unsigned long event,
 			hnat_priv->g_wandev = dev_get_by_name(&init_net, hnat_priv->wan);
 
 		break;
-	case MTK_FE_RESET_NAT_DONE:
+	/*TODO:case MTK_FE_RESET_NAT_DONE:
 		pr_info("[%s] HNAT driver starts to do warm init !\n", __func__);
 		hnat_warm_init();
-		break;
+		break;*/
 	default:
 		break;
 	}
@@ -290,13 +299,16 @@ void foe_clear_entry(struct neighbour *neigh)
 
 		for (hash_index = 0; hash_index < hnat_priv->foe_etry_num; hash_index++) {
 			entry = hnat_priv->foe_table_cpu[i] + hash_index;
+			/*if (entry->bfib1.state == BIND &&
+			    entry->ipv4_hnapt.new_dip == ntohl(dip)) {*/
 			if (entry->bfib1.state == BIND &&
 			    entry->ipv4_hnapt.new_dip == ntohl(dip) &&
 			    IS_IPV4_HNAPT(entry)) {
 				*((u32 *)h_dest) = swab32(entry->ipv4_hnapt.dmac_hi);
 				*((u16 *)&h_dest[4]) =
 					swab16(entry->ipv4_hnapt.dmac_lo);
-				if (strncmp(h_dest, neigh->ha, ETH_ALEN) != 0) {
+				if (!ether_addr_equal(h_dest, neigh->ha)) {
+				//TODO:if (strncmp(h_dest, neigh->ha, ETH_ALEN) != 0) {
 					pr_info("%s: state=%d\n", __func__,
 						neigh->nud_state);
 					cr_set_field(hnat_priv->ppe_base[i] + PPE_TB_CFG,
@@ -396,9 +408,10 @@ unsigned int do_hnat_ext_to_ge(struct sk_buff *skb, const struct net_device *in,
 		}
 
 		/*set where we come from*/
-		skb->vlan_proto = htons(ETH_P_8021Q);
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), in->ifindex & VLAN_VID_MASK);
+		/*skb->vlan_proto = htons(ETH_P_8021Q);
 		skb->vlan_tci =
-			(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));
+			(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));*/
 		trace_printk(
 			"%s: vlan_prot=0x%x, vlan_tci=%x, in->name=%s, skb->dev->name=%s\n",
 			__func__, ntohs(skb->vlan_proto), skb->vlan_tci,
@@ -504,6 +517,7 @@ unsigned int do_hnat_ge_to_ext(struct sk_buff *skb, const char *func)
 
 	skb->dev = dev;
 
+	//if (qos_toggle && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 	if (IS_HQOS_MODE && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 		skb = skb_unshare(skb, GFP_ATOMIC);
 		if (!skb)
@@ -597,8 +611,11 @@ static inline void hnat_set_iif(const struct nf_hook_state *state,
 		skb_hnat_iface(skb) = FOE_MAGIC_EXT;
 	} else if (IS_WAN(state->in)) {
 		skb_hnat_iface(skb) = FOE_MAGIC_GE_WAN;
+	/*FIXME:} else if (state->in->netdev_ops->ndo_hnat_check) {
+		skb_hnat_iface(skb) = FOE_MAGIC_GE_VIRTUAL;*/
 	} else if (!IS_BR(state->in)) {
-		if (state->in->netdev_ops->ndo_flow_offload_check) {
+		if (state->in->netdev_ops->ndo_hnat_check) {
+		//if (state->in->netdev_ops->ndo_flow_offload_check) {
 			skb_hnat_iface(skb) = FOE_MAGIC_GE_VIRTUAL;
 		} else {
 			skb_hnat_iface(skb) = FOE_INVALID;
@@ -672,9 +689,10 @@ unsigned int do_hnat_mape_w2l_fast(struct sk_buff *skb, const struct net_device
 		eth->h_proto = htons(ETH_P_IP);
 		set_to_ppe(skb);
 
-		skb->vlan_proto = htons(ETH_P_8021Q);
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), in->ifindex & VLAN_VID_MASK);
+		/*skb->vlan_proto = htons(ETH_P_8021Q);
 		skb->vlan_tci =
-		(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));
+		(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));*/
 
 		if (!hnat_priv->g_ppdev)
 			hnat_priv->g_ppdev = dev_get_by_name(&init_net, hnat_priv->ppd);
@@ -708,6 +726,75 @@ void mtk_464xlat_pre_process(struct sk_buff *skb)
 		       sizeof(struct hnat_desc));
 }
 
+#if defined(CONFIG_MEDIATEK_NETSYS_V2)
+unsigned int do_hnat_mape_w2l(struct sk_buff *skb, const struct net_device *in,
+				   const char *func)
+{
+	struct ipv6hdr *ip6h = ipv6_hdr(skb);
+	struct iphdr _iphdr;
+	struct iphdr *iph;
+	struct foe_entry *entry;
+	struct tcpudphdr _ports;
+	const struct tcpudphdr *pptr;
+	int udp = 0;
+
+	/* WAN -> LAN/WLAN MapE learn info(include innner IPv4 header info). */
+	if (ip6h->nexthdr == NEXTHDR_IPIP) {
+		entry = &hnat_priv->foe_table_cpu[skb_hnat_ppe(skb)][skb_hnat_entry(skb)];
+
+		entry->ipv4_dslite.tunnel_sipv6_0 =
+			ntohl(ip6h->saddr.s6_addr32[0]);
+		entry->ipv4_dslite.tunnel_sipv6_1 =
+			ntohl(ip6h->saddr.s6_addr32[1]);
+		entry->ipv4_dslite.tunnel_sipv6_2 =
+			ntohl(ip6h->saddr.s6_addr32[2]);
+		entry->ipv4_dslite.tunnel_sipv6_3 =
+			ntohl(ip6h->saddr.s6_addr32[3]);
+
+		entry->ipv4_dslite.tunnel_dipv6_0 =
+			ntohl(ip6h->daddr.s6_addr32[0]);
+		entry->ipv4_dslite.tunnel_dipv6_1 =
+			ntohl(ip6h->daddr.s6_addr32[1]);
+		entry->ipv4_dslite.tunnel_dipv6_2 =
+			ntohl(ip6h->daddr.s6_addr32[2]);
+		entry->ipv4_dslite.tunnel_dipv6_3 =
+			ntohl(ip6h->daddr.s6_addr32[3]);
+
+		ppe_fill_flow_lbl(entry, ip6h);
+
+		iph = skb_header_pointer(skb, IPV6_HDR_LEN,
+					 sizeof(_iphdr), &_iphdr);
+		if (unlikely(!iph))
+			return NF_ACCEPT;
+
+		switch (iph->protocol) {
+		case IPPROTO_UDP:
+			udp = 1;
+		case IPPROTO_TCP:
+		break;
+
+		default:
+			return NF_ACCEPT;
+		}
+
+		pptr = skb_header_pointer(skb, IPV6_HDR_LEN + iph->ihl * 4,
+					  sizeof(_ports), &_ports);
+		if (unlikely(!pptr))
+			return NF_ACCEPT;
+
+		entry->bfib1.udp = udp;
+
+		entry->ipv4_dslite.new_sip = ntohl(iph->saddr);
+		entry->ipv4_dslite.new_dip = ntohl(iph->daddr);
+		entry->ipv4_dslite.new_sport = ntohs(pptr->src);
+		entry->ipv4_dslite.new_dport = ntohs(pptr->dst);
+
+		return 0;
+	}
+	return -1;
+}
+#endif
+
 static unsigned int is_ppe_support_type(struct sk_buff *skb)
 {
 	struct ethhdr *eth = NULL;
@@ -716,6 +803,9 @@ static unsigned int is_ppe_support_type(struct sk_buff *skb)
 	struct iphdr _iphdr;
 
 	eth = eth_hdr(skb);
+	//FIXME:if (is_broadcast_ether_addr(eth->h_dest))
+	/*if (!is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb) ||
+	    is_multicast_ether_addr(eth->h_dest))*/
 	if (!is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb) ||
 	    is_broadcast_ether_addr(eth->h_dest))
 		return 0;
@@ -795,10 +885,15 @@ mtk_hnat_ipv6_nf_pre_routing(void *priv, struct sk_buff *skb,
 #if !(defined(CONFIG_MEDIATEK_NETSYS_V2) || defined(CONFIG_MEDIATEK_NETSYS_V3))
 	/* MapE need remove ipv6 header and pingpong. */
 	if (do_mape_w2l_fast(state->in, skb)) {
+#if defined(CONFIG_MEDIATEK_NETSYS_V2)
+		if (mape_toggle && do_hnat_mape_w2l(skb, state->in, __func__))
+			return NF_ACCEPT;
+#else
 		if (!do_hnat_mape_w2l_fast(skb, state->in, __func__))
 			return NF_STOLEN;
 		else
 			return NF_ACCEPT;
+#endif
 	}
 
 	if (is_from_mape(skb))
@@ -825,8 +920,8 @@ static unsigned int
 mtk_hnat_ipv4_nf_pre_routing(void *priv, struct sk_buff *skb,
 			     const struct nf_hook_state *state)
 {
-	struct flow_offload_hw_path hw_path = { .dev = skb->dev,
-						.virt_dev = skb->dev };
+	/*TODO:struct flow_offload_hw_path hw_path = { .dev = skb->dev,
+						.virt_dev = skb->dev };*/
 
 	if (!skb)
 		goto drop;
@@ -843,13 +938,13 @@ mtk_hnat_ipv4_nf_pre_routing(void *priv, struct sk_buff *skb,
 	 * In pre-routing, if dev is virtual iface, TOPS module is not loaded,
 	 * and it's L2TP flow, then do not bind.
 	 */
-	if (skb_hnat_iface(skb) == FOE_MAGIC_GE_VIRTUAL
+	/*TODO:if (skb_hnat_iface(skb) == FOE_MAGIC_GE_VIRTUAL
 	    && skb->dev->netdev_ops->ndo_flow_offload_check) {
 		skb->dev->netdev_ops->ndo_flow_offload_check(&hw_path);
 
 		if (hw_path.flags & FLOW_OFFLOAD_PATH_TNL)
 			skb_hnat_alg(skb) = 1;
-	}
+	}*/
 
 	pre_routing_print(skb, state->in, state->out, __func__);
 
@@ -894,6 +989,7 @@ mtk_hnat_br_nf_local_in(void *priv, struct sk_buff *skb,
 	if (!skb)
 		goto drop;
 
+	//if (qos_toggle && hnat_priv->data->whnat) {
 	if (IS_HQOS_MODE && hnat_priv->data->whnat) {
 		veth = (struct vlan_ethhdr *)skb_mac_header(skb);
 
@@ -974,15 +1070,18 @@ drop:
 
 static unsigned int hnat_ipv6_get_nexthop(struct sk_buff *skb,
 					  const struct net_device *out,
-					  struct flow_offload_hw_path *hw_path)
+					  struct hnat_hw_path *hw_path)
+					  //struct flow_offload_hw_path *hw_path)
 {
-	const struct in6_addr *ipv6_nexthop;
+	struct in6_addr *ipv6_nexthop;
+	//const struct in6_addr *ipv6_nexthop;
 	struct neighbour *neigh = NULL;
 	struct dst_entry *dst = skb_dst(skb);
 	struct ethhdr *eth;
 	u16 eth_pppoe_hlen = ETH_HLEN + PPPOE_SES_HLEN;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
+	if (hw_path->flags & HNAT_PATH_PPPOE) {
+	//if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
 		if (ipv6_hdr(skb)->nexthdr == NEXTHDR_IPIP) {
 			eth = (struct ethhdr *)(skb->data - eth_pppoe_hlen);
 			eth->h_proto = skb->protocol;
@@ -1032,7 +1131,8 @@ static unsigned int hnat_ipv6_get_nexthop(struct sk_buff *skb,
 
 static unsigned int hnat_ipv4_get_nexthop(struct sk_buff *skb,
 					  const struct net_device *out,
-					  struct flow_offload_hw_path *hw_path)
+					  struct hnat_hw_path *hw_path)
+					  //struct flow_offload_hw_path *hw_path)
 {
 	u32 nexthop;
 	struct neighbour *neigh;
@@ -1040,7 +1140,8 @@ static unsigned int hnat_ipv4_get_nexthop(struct sk_buff *skb,
 	struct rtable *rt = (struct rtable *)dst;
 	struct net_device *dev = (__force struct net_device *)out;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
+	if (hw_path->flags & HNAT_PATH_PPPOE) {
+	//if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
 		memcpy(eth_hdr(skb)->h_source, hw_path->eth_src, ETH_ALEN);
 		memcpy(eth_hdr(skb)->h_dest, hw_path->eth_dest, ETH_ALEN);
 		return 0;
@@ -1091,7 +1192,8 @@ static u16 ppe_get_chkbase(struct iphdr *iph)
 }
 
 struct foe_entry ppe_fill_L2_info(struct ethhdr *eth, struct foe_entry entry,
-				  struct flow_offload_hw_path *hw_path)
+				  struct hnat_hw_path *hw_path)
+				  //struct flow_offload_hw_path *hw_path)
 {
 	switch ((int)entry.bfib1.pkt_type) {
 	case IPV4_HNAPT:
@@ -1101,6 +1203,8 @@ struct foe_entry ppe_fill_L2_info(struct ethhdr *eth, struct foe_entry entry,
 		entry.ipv4_hnapt.smac_hi = swab32(*((u32 *)eth->h_source));
 		entry.ipv4_hnapt.smac_lo = swab16(*((u16 *)&eth->h_source[4]));
 		entry.ipv4_hnapt.pppoe_id = hw_path->pppoe_sid;
+		/*entry.ipv4_hnapt.pppoe_id = (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) ?
+					     hw_path->encap.id : 0;*/
 		break;
 	case IPV4_DSLITE:
 	case IPV4_MAP_E:
@@ -1115,18 +1219,25 @@ struct foe_entry ppe_fill_L2_info(struct ethhdr *eth, struct foe_entry entry,
 		entry.ipv6_5t_route.smac_lo =
 			swab16(*((u16 *)&eth->h_source[4]));
 		entry.ipv6_5t_route.pppoe_id = hw_path->pppoe_sid;
+		/*entry.ipv6_5t_route.pppoe_id = (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) ?
+						hw_path->encap.id : 0;*/
 		break;
 	}
 	return entry;
 }
 
 struct foe_entry ppe_fill_info_blk(struct ethhdr *eth, struct foe_entry entry,
-				   struct flow_offload_hw_path *hw_path)
+				   struct hnat_hw_path *hw_path)
+				   //struct flow_offload_hw_path *hw_path)
 {
-	entry.bfib1.psn = (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) ? 1 : 0;
-	entry.bfib1.vlan_layer += (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ? 1 : 0;
+	entry.bfib1.psn = (hw_path->flags & HNAT_PATH_PPPOE) ? 1 : 0;
+	entry.bfib1.vlan_layer += (hw_path->flags & HNAT_PATH_VLAN) ? 1 : 0;
+	/*entry.bfib1.psn = (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) ? 1 : 0;
+	entry.bfib1.vlan_layer += (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ? 1 : 0;*/
 	entry.bfib1.vpm = (entry.bfib1.vlan_layer) ? 1 : 0;
+	//FIXME:entry.bfib1.ttl = 1;
 	entry.bfib1.cah = 1;
+	//FIXME:entry.bfib1.ka = 1;
 	entry.bfib1.time_stamp = (hnat_priv->data->version == MTK_HNAT_V2 ||
 				  hnat_priv->data->version == MTK_HNAT_V3) ?
 		readl(hnat_priv->fe_base + 0x0010) & (0xFF) :
@@ -1135,6 +1246,7 @@ struct foe_entry ppe_fill_info_blk(struct ethhdr *eth, struct foe_entry entry,
 	switch ((int)entry.bfib1.pkt_type) {
 	case IPV4_HNAPT:
 	case IPV4_HNAT:
+		//if (is_multicast_ether_addr(&eth->h_dest[0])) {
 		if (hnat_priv->data->mcast &&
 		    is_multicast_ether_addr(&eth->h_dest[0])) {
 			entry.ipv4_hnapt.iblk2.mcast = 1;
@@ -1157,6 +1269,7 @@ struct foe_entry ppe_fill_info_blk(struct ethhdr *eth, struct foe_entry entry,
 	case IPV6_3T_ROUTE:
 	case IPV6_HNAPT:
 	case IPV6_HNAT:
+		//if (is_multicast_ether_addr(&eth->h_dest[0])) {
 		if (hnat_priv->data->mcast &&
 		    is_multicast_ether_addr(&eth->h_dest[0])) {
 			entry.ipv6_5t_route.iblk2.mcast = 1;
@@ -1177,12 +1290,14 @@ struct foe_entry ppe_fill_info_blk(struct ethhdr *eth, struct foe_entry entry,
 }
 
 static struct ethhdr *get_ipv6_ipip_ethhdr(struct sk_buff *skb,
-					   struct flow_offload_hw_path *hw_path)
+					   struct hnat_hw_path *hw_path)
+					   //struct flow_offload_hw_path *hw_path)
 {
 	struct ethhdr *eth;
 	u16 eth_pppoe_hlen = ETH_HLEN + PPPOE_SES_HLEN;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE)
+	if (hw_path->flags & HNAT_PATH_PPPOE)
+	//if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE)
 		eth = (struct ethhdr *)(skb->data - eth_pppoe_hlen);
 	else
 		eth = (struct ethhdr *)(skb->data - ETH_HLEN);
@@ -1193,7 +1308,8 @@ static struct ethhdr *get_ipv6_ipip_ethhdr(struct sk_buff *skb,
 static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				     const struct net_device *dev,
 				     struct foe_entry *foe,
-				     struct flow_offload_hw_path *hw_path)
+				     struct hnat_hw_path *hw_path)
+				     //struct flow_offload_hw_path *hw_path)
 {
 	struct foe_entry entry = { 0 };
 	int whnat = IS_WHNAT(dev);
@@ -1210,6 +1326,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 	u32 port_id = 0;
 	int mape = 0;
 
+	//FIXME:
 	ct = nf_ct_get(skb, &ctinfo);
 
 	if (ipv6_hdr(skb)->nexthdr == NEXTHDR_IPIP)
@@ -1218,11 +1335,17 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 	else
 		eth = eth_hdr(skb);
 
+	//if (is_multicast_ether_addr(eth->h_dest)) {
+	//	/*do not bind multicast if PPE mcast not enable*/
+	//	if (!hnat_priv->pmcast)
+	//		return 0;
+	//}
 	/*do not bind multicast if PPE mcast not enable*/
 	if (!hnat_priv->data->mcast && is_multicast_ether_addr(eth->h_dest))
 		return 0;
 
 	entry.bfib1.pkt_type = foe->udib1.pkt_type; /* Get packte type state*/
+	//FIXME:
 	entry.bfib1.state = foe->udib1.state;
 
 #if defined(CONFIG_MEDIATEK_NETSYS_V2) || defined(CONFIG_MEDIATEK_NETSYS_V3)
@@ -1290,6 +1413,9 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				entry.ipv4_dslite.bfib1.rmt = 1;
 				entry.ipv4_dslite.iblk2.dscp = iph->tos;
 				entry.ipv4_dslite.vlan1 = hw_path->vlan_id;
+				/*entry.ipv4_dslite.vlan1 =
+					(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+					 hw_path->encap.id : 0;*/
 				if (hnat_priv->data->per_flow_accounting)
 					entry.ipv4_dslite.iblk2.mibf = 1;
 
@@ -1299,7 +1425,18 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 					entry.ipv4_hnapt.iblk2.mibf = 1;
 
 				entry.ipv4_hnapt.vlan1 = hw_path->vlan_id;
+				/*entry.ipv4_hnapt.vlan1 =
+					(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+					 hw_path->encap.id : 0;*/
 
+				/*if (skb->vlan_tci && FROM_GE_WAN(skb) && IS_LAN(dev)) {
+					entry.bfib1.vlan_layer += 1;
+
+					if (entry.ipv4_hnapt.vlan1)
+						entry.ipv4_hnapt.vlan2 = (skb->vlan_tci & VLAN_VID_MASK);
+					else
+						entry.ipv4_hnapt.vlan1 = (skb->vlan_tci & VLAN_VID_MASK);
+				}*/
 				if (skb_vlan_tag_present(skb)) {
 					entry.bfib1.vlan_layer += 1;
 
@@ -1353,7 +1490,18 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 			entry.ipv6_5t_route.etype = htons(ETH_P_IPV6);
 
 			entry.ipv6_5t_route.vlan1 = hw_path->vlan_id;
+			/*entry.ipv6_5t_route.vlan1 =
+				(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+				 hw_path->encap.id : 0;*/
+
+			/*if (skb->vlan_tci && FROM_GE_WAN(skb) && IS_LAN(dev)) {
+				entry.bfib1.vlan_layer += 1;
 
+				if (entry.ipv6_5t_route.vlan1)
+					entry.ipv6_5t_route.vlan2 = (skb->vlan_tci & VLAN_VID_MASK);
+				else
+					entry.ipv6_5t_route.vlan1 = (skb->vlan_tci & VLAN_VID_MASK);
+			}*/
 			if (skb_vlan_tag_present(skb)) {
 				entry.bfib1.vlan_layer += 1;
 
@@ -1466,6 +1614,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 			    (mape_toggle &&
 			     entry.bfib1.pkt_type == IPV4_MAP_E)) {
 				/* DS-Lite LAN->WAN */
+				//FIXME:
 				entry.ipv4_dslite.bfib1.udp =
 					foe->ipv4_dslite.bfib1.udp;
 				entry.ipv4_dslite.sip = foe->ipv4_dslite.sip;
@@ -1498,6 +1647,9 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				entry.ipv4_dslite.priority = ip6h->priority;
 				entry.ipv4_dslite.hop_limit = ip6h->hop_limit;
 				entry.ipv4_dslite.vlan1 = hw_path->vlan_id;
+				/*entry.ipv4_dslite.vlan1 =
+					(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+					 hw_path->encap.id : 0;*/
 				if (hnat_priv->data->per_flow_accounting)
 					entry.ipv4_dslite.iblk2.mibf = 1;
 				/* Map-E LAN->WAN record inner IPv4 header info. */
@@ -1519,10 +1671,14 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				if (hnat_priv->data->per_flow_accounting)
 					entry.ipv4_hnapt.iblk2.mibf = 1;
 
+				//FIXME:
 				if (IS_GMAC1_MODE)
 					entry.ipv4_hnapt.vlan1 = 1;
 				else
 					entry.ipv4_hnapt.vlan1 = hw_path->vlan_id;
+					/*entry.ipv4_hnapt.vlan1 =
+						(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+						 hw_path->encap.id : 0;*/
 
 				entry.ipv4_hnapt.sip = foe->ipv4_hnapt.sip;
 				entry.ipv4_hnapt.dip = foe->ipv4_hnapt.dip;
@@ -1535,6 +1691,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 					foe->ipv4_hnapt.new_dip;
 				entry.ipv4_hnapt.etype = htons(ETH_P_IP);
 
+				//if (qos_toggle) {
 				if (IS_HQOS_MODE) {
 					entry.ipv4_hnapt.iblk2.qid =
 						(hnat_priv->data->version ==
@@ -1578,6 +1735,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 		break;
 
 	default:
+		//FIXME:ip6h = ipv6_hdr(skb);
 		iph = ip_hdr(skb);
 		switch (entry.bfib1.pkt_type) {
 		case IPV6_6RD: /* 6RD LAN->WAN */
@@ -1601,6 +1759,9 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 			entry.ipv6_6rd.dscp = iph->tos;
 			entry.ipv6_6rd.per_flow_6rd_id = 1;
 			entry.ipv6_6rd.vlan1 = hw_path->vlan_id;
+			/*entry.ipv6_6rd.vlan1 =
+				(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+				 hw_path->encap.id : 0;*/
 			if (hnat_priv->data->per_flow_accounting)
 				entry.ipv6_6rd.iblk2.mibf = 1;
 			break;
@@ -1625,8 +1786,12 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 		if (IS_BOND_MODE)
 			gmac = ((skb_hnat_entry(skb) >> 1) % hnat_priv->gmac_num) ?
 				 NR_GMAC2_PORT : NR_GMAC1_PORT;
-		else
-			gmac = NR_GMAC1_PORT;
+		else {
+			if (of_machine_is_compatible("glinet,gl-mt3000")||of_machine_is_compatible("glinet,mt3000-snand"))
+				gmac = NR_GMAC2_PORT;
+			else
+				gmac = NR_GMAC1_PORT;
+		}
 	} else if (IS_LAN2(dev)) {
 		gmac = NR_GMAC3_PORT;
 	} else if (IS_WAN(dev)) {
@@ -1639,8 +1804,13 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 			/* Set act_dp = wan_dev */
 			entry.ipv4_hnapt.act_dp = dev->ifindex;
 		} else {
-			gmac = (IS_GMAC1_MODE) ? NR_GMAC1_PORT : NR_GMAC2_PORT;
+			if (of_machine_is_compatible("glinet,gl-mt3000")||of_machine_is_compatible("glinet,mt3000-snand"))
+				gmac = NR_GMAC1_PORT;
+			else
+				gmac = (IS_GMAC1_MODE) ? NR_GMAC1_PORT : NR_GMAC2_PORT;
 		}
+	/*FIXME:} else if (IS_EXT(dev)) {
+		if ((hnat_priv->data->version != MTK_HNAT_V2) && IS_GMAC1_MODE) {*/
 	} else if (IS_EXT(dev) && (FROM_GE_PPD(skb) || FROM_GE_LAN_GRP(skb) ||
 		   FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb) || FROM_WED(skb))) {
 		if (!hnat_priv->data->whnat && IS_GMAC1_MODE) {
@@ -1671,8 +1841,10 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 		return 0;
 	}
 
+	//if (IS_HQOS_MODE)
 	if (IS_HQOS_MODE || skb->mark >= MAX_PPPQ_PORT_NUM)
 		qid = skb->mark & (MTK_QDMA_TX_MASK);
+	//else if (IS_PPPQ_MODE)
 	else if (IS_PPPQ_MODE && IS_PPPQ_PATH(dev, skb))
 		qid = port_id & MTK_QDMA_TX_MASK;
 	else
@@ -1704,6 +1876,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				}
 			}
 
+			//if (FROM_EXT(skb) || skb_hnat_sport(skb) == NR_QDMA_PORT)
 			if (FROM_EXT(skb) || skb_hnat_sport(skb) == NR_QDMA_PORT ||
 			    (IS_PPPQ_MODE && !IS_DSA_LAN(dev) && !IS_DSA_WAN(dev)))
 				entry.ipv4_hnapt.iblk2.fqos = 0;
@@ -1750,6 +1923,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				}
 			}
 
+			//if (FROM_EXT(skb))
 			if (FROM_EXT(skb) ||
 			    (IS_PPPQ_MODE && !IS_DSA_LAN(dev) && !IS_DSA_WAN(dev)))
 				entry.ipv6_5t_route.iblk2.fqos = 0;
@@ -1778,10 +1952,12 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 	 * the entry is set to BIND state in mtk_sw_nat_hook_tx().
 	 */
 	if (!whnat) {
+		//FIXME:
 		entry.bfib1.ttl = 1;
 		entry.bfib1.state = BIND;
 	}
 
+	//FIXME:
 	wmb();
 	memcpy(foe, &entry, sizeof(entry));
 	/*reset statistic for this entry*/
@@ -1802,6 +1978,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 	struct ethhdr *eth;
 	struct hnat_bind_info_blk bfib1_tx;
 
+	//FIXME:if (skb_hnat_alg(skb) || !is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb))
 	if (skb_hnat_alg(skb) || !is_hnat_info_filled(skb) ||
 	    !is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb))
 		return NF_ACCEPT;
@@ -1812,6 +1989,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 		skb_hnat_wdma_id(skb), skb_hnat_bss_id(skb),
 		skb_hnat_wc_id(skb), skb_hnat_rx_id(skb));
 
+	//FIXME:
 	if ((gmac_no != NR_WDMA0_PORT) && (gmac_no != NR_WDMA1_PORT) &&
 	    (gmac_no != NR_WHNAT_WDMA_PORT))
 		return NF_ACCEPT;
@@ -1834,8 +2012,14 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 		return NF_ACCEPT;
 
 	eth = eth_hdr(skb);
+	//FIXME:
 	memcpy(&bfib1_tx, &entry->bfib1, sizeof(entry->bfib1));
 
+	//if (is_multicast_ether_addr(eth->h_dest)) {
+	//	/*not bind multicast if PPE mcast not enable*/
+	//	if (!hnat_priv->pmcast)
+	//		return NF_ACCEPT;
+	//}
 	/*not bind multicast if PPE mcast not enable*/
 	if (!hnat_priv->data->mcast) {
 		if (is_multicast_ether_addr(eth->h_dest))
@@ -1873,9 +2057,17 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 		bfib1_tx.vpm = 1;
 		if (IS_IPV4_GRP(entry)) {
 			entry->ipv4_hnapt.etype = htons(ETH_P_8021Q);
+			/*FIXME:if(entry->ipv4_hnapt.vlan1)
+				entry->ipv4_hnapt.vlan2 = skb->vlan_tci;
+			else
+				entry->ipv4_hnapt.vlan1 = skb->vlan_tci;*/
 			entry->ipv4_hnapt.vlan1 = skb->vlan_tci;
 		} else if (IS_IPV6_GRP(entry)) {
 			entry->ipv6_5t_route.etype = htons(ETH_P_8021Q);
+			/*FIXME:if(entry->ipv6_5t_route.vlan1)
+				entry->ipv6_5t_route.vlan2 = skb->vlan_tci;
+			else
+				entry->ipv6_5t_route.vlan1 = skb->vlan_tci;*/
 			entry->ipv6_5t_route.vlan1 = skb->vlan_tci;
 		}
 	} else {
@@ -1894,6 +2086,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 			entry->ipv4_hnapt.winfo.bssid = skb_hnat_bss_id(skb);
 			entry->ipv4_hnapt.winfo.wcid = skb_hnat_wc_id(skb);
 #if defined(CONFIG_MEDIATEK_NETSYS_V3)
+			//entry->ipv4_hnapt.iblk2.fqos = (qos_toggle) ? 1 : 0;
 			entry->ipv4_hnapt.tport_id = IS_HQOS_DL_MODE ? 1 : 0;
 			entry->ipv4_hnapt.iblk2.rxid = skb_hnat_rx_id(skb);
 			entry->ipv4_hnapt.iblk2.winfoi = 1;
@@ -1908,6 +2101,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 			entry->ipv4_hnapt.winfo_pao.hf = skb_hnat_hf(skb);
 			entry->ipv4_hnapt.winfo_pao.amsdu = skb_hnat_amsdu(skb);
 #elif defined(CONFIG_MEDIATEK_NETSYS_V2)
+			//entry->ipv4_hnapt.iblk2.fqos = (qos_toggle) ? 1 : 0;
 			entry->ipv4_hnapt.iblk2.rxid = skb_hnat_rx_id(skb);
 			entry->ipv4_hnapt.iblk2.winfoi = 1;
 #else
@@ -1926,6 +2120,8 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 					entry->ipv4_hnapt.vlan1 = 2;
 			}
 
+			/*if (qos_toggle &&
+			    (FROM_GE_LAN_GRP(skb) || FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {*/
 			if (IS_HQOS_MODE &&
 			    (FROM_GE_LAN_GRP(skb) || FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {
 				bfib1_tx.vpm = 0;
@@ -1964,6 +2160,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 			entry->ipv6_5t_route.winfo.bssid = skb_hnat_bss_id(skb);
 			entry->ipv6_5t_route.winfo.wcid = skb_hnat_wc_id(skb);
 #if defined(CONFIG_MEDIATEK_NETSYS_V3)
+			//entry->ipv6_5t_route.iblk2.fqos = (qos_toggle) ? 1 : 0;
 			entry->ipv6_5t_route.tport_id = IS_HQOS_DL_MODE ? 1 : 0;
 			entry->ipv6_5t_route.iblk2.rxid = skb_hnat_rx_id(skb);
 			entry->ipv6_5t_route.iblk2.winfoi = 1;
@@ -1982,6 +2179,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 			entry->ipv6_5t_route.winfo_pao.amsdu =
 				skb_hnat_amsdu(skb);
 #elif defined(CONFIG_MEDIATEK_NETSYS_V2)
+			//entry->ipv6_5t_route.iblk2.fqos = (qos_toggle) ? 1 : 0;
 			entry->ipv6_5t_route.iblk2.rxid = skb_hnat_rx_id(skb);
 			entry->ipv6_5t_route.iblk2.winfoi = 1;
 #else
@@ -2000,6 +2198,8 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 					entry->ipv6_5t_route.vlan1 = 2;
 			}
 
+			/*if (qos_toggle &&
+			    (FROM_GE_LAN_GRP(skb) || FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {*/
 			if (IS_HQOS_MODE &&
 			    (FROM_GE_LAN_GRP(skb) || FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {
 				bfib1_tx.vpm = 0;
@@ -2012,8 +2212,10 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 		entry->ipv6_5t_route.iblk2.dp = gmac_no;
 	}
 
+	//FIXME:
 	bfib1_tx.ttl = 1;
 	bfib1_tx.state = BIND;
+	//FIXME:
 	wmb();
 	memcpy(&entry->bfib1, &bfib1_tx, sizeof(bfib1_tx));
 
@@ -2044,6 +2246,14 @@ void mtk_ppe_dev_register_hook(struct net_device *dev)
 	int i, number = 0;
 	struct extdev_entry *ext_entry;
 
+	/*FIXME:if (dev->name && !strcmp(dev->name, "wds"))
+		return;*/
+
+	/*TODO:if (!hnat_priv->guest_en && dev->name) {
+		if (!strcmp(dev->name, "ra1") || !strcmp(dev->name, "rai1") || !strcmp(dev->name, "rax1"))
+			return;
+	}*/
+
 	for (i = 1; i < MAX_IF_NUM; i++) {
 		if (hnat_priv->wifi_hook_if[i] == dev) {
 			pr_info("%s : %s has been registered in wifi_hook_if table[%d]\n",
@@ -2139,11 +2349,15 @@ static void mtk_hnat_dscp_update(struct sk_buff *skb, struct foe_entry *entry)
 	switch (ntohs(eth->h_proto)) {
 	case ETH_P_IP:
 		iph = ip_hdr(skb);
+		//if (entry->ipv4_hnapt.iblk2.dscp != iph->tos)
 		if (IS_IPV4_GRP(entry) && entry->ipv4_hnapt.iblk2.dscp != iph->tos)
 			flag = true;
 		break;
 	case ETH_P_IPV6:
 		ip6h = ipv6_hdr(skb);
+		/*if (entry->ipv6_5t_route.iblk2.dscp !=
+			(ip6h->priority << 4 |
+			 (ip6h->flow_lbl[0] >> 4)))*/
 		if ((IS_IPV6_3T_ROUTE(entry) || IS_IPV6_5T_ROUTE(entry)) &&
 			(entry->ipv6_5t_route.iblk2.dscp !=
 			(ip6h->priority << 4 | (ip6h->flow_lbl[0] >> 4))))
@@ -2468,14 +2682,20 @@ int mtk_464xlat_post_process(struct sk_buff *skb, const struct net_device *out)
 static unsigned int mtk_hnat_nf_post_routing(
 	struct sk_buff *skb, const struct net_device *out,
 	unsigned int (*fn)(struct sk_buff *, const struct net_device *,
-			   struct flow_offload_hw_path *),
+			   struct hnat_hw_path *),
+			   //struct flow_offload_hw_path *),
 	const char *func)
 {
 	struct foe_entry *entry;
-	struct flow_offload_hw_path hw_path = { .dev = (struct net_device*)out,
-						.virt_dev = (struct net_device*)out };
+	struct hnat_hw_path hw_path = { .real_dev = out, .virt_dev = out };
+	/*struct flow_offload_hw_path hw_path = { .dev = (struct net_device*)out,
+						.virt_dev = (struct net_device*)out };*/
 	const struct net_device *arp_dev = out;
 
+	/*TODO:if (skb->protocol == htons(ETH_P_IPV6) && !hnat_priv->ipv6_en) {
+		return 0;
+	}*/
+
 	if (xlat_toggle && !mtk_464xlat_post_process(skb, out))
 		return 0;
 
@@ -2483,6 +2703,7 @@ static unsigned int mtk_hnat_nf_post_routing(
 					  !IS_SPACE_AVAILABLE_HEAD(skb)))
 		return 0;
 
+	//FIXME:
 	if (unlikely(!skb_mac_header_was_set(skb)))
 		return 0;
 
@@ -2493,9 +2714,13 @@ static unsigned int mtk_hnat_nf_post_routing(
 	if (ip_is_fragment(ip_hdr(skb)))
 		return 0;
 
-	if (out->netdev_ops->ndo_flow_offload_check) {
+	if (out->netdev_ops->ndo_hnat_check) {
+		if (out->netdev_ops->ndo_hnat_check(&hw_path))
+			return 0;
+		out = (IS_GMAC1_MODE) ? hw_path.virt_dev : hw_path.real_dev;
+	/*if (out->netdev_ops->ndo_flow_offload_check) {
 		out->netdev_ops->ndo_flow_offload_check(&hw_path);
-		out = (IS_GMAC1_MODE) ? hw_path.virt_dev : hw_path.dev;
+		out = (IS_GMAC1_MODE) ? hw_path.virt_dev : hw_path.dev;*/
 	}
 
 	if (!IS_LAN_GRP(out) && !IS_WAN(out) && !IS_EXT(out))
@@ -2524,6 +2749,7 @@ static unsigned int mtk_hnat_nf_post_routing(
 		skb_to_hnat_info(skb, out, entry, &hw_path);
 		break;
 	case HIT_BIND_KEEPALIVE_DUP_OLD_HDR:
+		//FIXME:
 		/* update hnat count to nf_conntrack by keepalive */
 		if (hnat_priv->data->per_flow_accounting && hnat_priv->nf_stat_en)
 			mtk_hnat_nf_update(skb);
@@ -2531,6 +2757,7 @@ static unsigned int mtk_hnat_nf_post_routing(
 		if (fn && !mtk_hnat_accel_type(skb))
 			break;
 
+		//FIXME:
 		/* update dscp for qos */
 		mtk_hnat_dscp_update(skb, entry);
 
@@ -2540,6 +2767,7 @@ static unsigned int mtk_hnat_nf_post_routing(
 			entry->ipv4_hnapt.m_timestamp = foe_timestamp(hnat_priv);
 
 		if (entry_hnat_is_bound(entry)) {
+			//FIXME:memset(skb_hnat_info(skb), 0, FOE_INFO_LEN);
 			memset(skb_hnat_info(skb), 0, sizeof(struct hnat_desc));
 
 			return -1;
@@ -2692,6 +2920,7 @@ mtk_pong_hqos_handler(void *priv, struct sk_buff *skb,
 
 	veth = (struct vlan_ethhdr *)skb_mac_header(skb);
 
+	//if (qos_toggle && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 	if (IS_HQOS_MODE && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 		skb_hnat_entry(skb) = ntohs(veth->h_vlan_TCI) & 0x3fff;
 		skb_hnat_reason(skb) = HIT_BIND_FORCE_TO_CPU;
@@ -2798,6 +3027,7 @@ static unsigned int mtk_hnat_br_nf_forward(void *priv,
 					   struct sk_buff *skb,
 					   const struct nf_hook_state *state)
 {
+	//FIXME:if (unlikely(IS_EXT(state->in) && IS_EXT(state->out)))
 	if ((hnat_priv->data->version == MTK_HNAT_V1_2) &&
 	    unlikely(IS_EXT(state->in) && IS_EXT(state->out)))
 		hnat_set_head_frags(state, skb, 1, hnat_set_alg);
@@ -2845,12 +3075,14 @@ static struct nf_hook_ops mtk_hnat_nf_ops[] __read_mostly = {
 	{
 		.hook = mtk_hnat_br_nf_local_in,
 		.pf = NFPROTO_BRIDGE,
+		//FIXME:.hooknum = NF_BR_PRE_ROUTING,
 		.hooknum = NF_BR_LOCAL_IN,
 		.priority = NF_BR_PRI_FIRST,
 	},
 	{
 		.hook = mtk_hnat_br_nf_local_out,
 		.pf = NFPROTO_BRIDGE,
+		//FIXME:.hooknum = NF_BR_POST_ROUTING,
 		.hooknum = NF_BR_LOCAL_OUT,
 		.priority = NF_BR_PRI_LAST - 1,
 	},
@@ -2864,11 +3096,13 @@ static struct nf_hook_ops mtk_hnat_nf_ops[] __read_mostly = {
 
 int hnat_register_nf_hooks(void)
 {
+	//FIXME:return nf_register_hooks(mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
 	return nf_register_net_hooks(&init_net, mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
 }
 
 void hnat_unregister_nf_hooks(void)
 {
+	//FIXME:nf_unregister_hooks(mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
 	nf_unregister_net_hooks(&init_net, mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
 }
 
@@ -2880,6 +3114,7 @@ int whnat_adjust_nf_hooks(void)
 	while (n-- > 0) {
 		if (hook[n].hook == mtk_hnat_br_nf_local_in) {
 			hook[n].hooknum = NF_BR_PRE_ROUTING;
+			//FIXME:
 			hook[n].priority = NF_BR_PRI_FIRST + 1;
 		} else if (hook[n].hook == mtk_hnat_br_nf_local_out) {
 			hook[n].hooknum = NF_BR_POST_ROUTING;
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_stag.c b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_stag.c
index 75c3a75c..3ef8075e 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_stag.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/hnat_stag.c
@@ -4,13 +4,14 @@
  * Author: Landen Chao <landen.chao@mediatek.com>
  */
 
-#include <linux/of_device.h>
-#include <net/netfilter/nf_flow_table.h>
+//#include <linux/of_device.h>
+//#include <net/netfilter/nf_flow_table.h>
 #include "hnat.h"
 
 u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 		       struct foe_entry *entry,
-		       struct flow_offload_hw_path *hw_path,
+		       struct hnat_hw_path *hw_path,
+		       //struct flow_offload_hw_path *hw_path,
 		       u16 eth_proto,
 		       int mape)
 {
@@ -19,8 +20,10 @@ u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 	int port_index;
 	u16 sp_tag;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN)
-		ndev = hw_path->dev;
+	if (hw_path->flags & HNAT_PATH_VLAN)
+		ndev = hw_path->real_dev;
+	/*if (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN)
+		ndev = hw_path->dev;*/
 	else
 		ndev = netdev;
 
@@ -40,6 +43,7 @@ u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 
 	switch (eth_proto) {
 	case ETH_P_IP:
+		//FIXME:if (entry->ipv4_hnapt.bfib1.pkt_type == IPV4_DSLITE)
 		if (entry->ipv4_hnapt.bfib1.pkt_type == IPV4_DSLITE
 			|| (entry->ipv4_hnapt.bfib1.pkt_type == IPV4_MAP_E))
 			entry->ipv4_dslite.etype = sp_tag;
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/nf_hnat_mtk.h b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/nf_hnat_mtk.h
index d9eba8dc..6bb66858 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/nf_hnat_mtk.h
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/mediatek/mtk_hnat/nf_hnat_mtk.h
@@ -16,7 +16,7 @@
 
 #include <linux/dma-mapping.h>
 #include <linux/netdevice.h>
-#include "../mtk_eth_soc.h"
+//#include "../mtk_eth_soc.h"
 
 #define HNAT_SKB_CB2(__skb) ((struct hnat_skb_cb2 *)&((__skb)->cb[44]))
 struct hnat_skb_cb2 {
@@ -68,14 +68,19 @@ struct hnat_desc {
 struct hnat_desc {
 	u32 entry : 14;
 	u32 crsn : 5;
+	/*u32 sport : 3;
+	u32 rev : 1;*/
 	u32 sport : 4;
 	u32 alg : 1;
+	//FIXME:u32 iface : 4;
 	u32 iface : 8;
+	//u32 resv : 4;
 	u32 filled : 3;
 	u32 resv : 1;
 	u32 magic_tag_protect : 16;
 	u32 wdmaid : 8;
 	u32 rxid : 2;
+	//FIXME:u32 wcid : 8;
 	u32 wcid : 10;
 	u32 bssid : 6;
 } __packed;
@@ -86,6 +91,7 @@ struct hnat_desc {
 
 #define HNAT_MAGIC_TAG 0x6789
 #define HNAT_INFO_FILLED 0x7
+//FIXME:#define WIFI_INFO_LEN 3
 #define WIFI_INFO_LEN 6
 #define FOE_INFO_LEN (10 + WIFI_INFO_LEN)
 #define IS_SPACE_AVAILABLE_HEAD(skb)                                           \
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/Makefile b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/Makefile
index bf1bbcbc..1bbd891b 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/Makefile
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/Makefile
@@ -1,5 +1,4 @@
 ccflags-y=-Werror
 
-obj-$(CONFIG_NET_MEDIATEK_HNAT)         += mtkhnat.o
-mtkhnat-objs := hnat.o hnat_nf_hook.o hnat_debugfs.o hnat_mcast.o
-mtkhnat-$(CONFIG_NET_DSA_MT7530)	+= hnat_stag.o
+obj-m         += hw_nat.o
+hw_nat-objs := hnat.o hnat_nf_hook.o hnat_debugfs.o hnat_mcast.o
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.c b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.c
index 7cda69f0..66771200 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.c
@@ -42,7 +42,8 @@ EXPORT_SYMBOL(ppe_dev_register_hook);
 void (*ppe_dev_unregister_hook)(struct net_device *dev) = NULL;
 EXPORT_SYMBOL(ppe_dev_unregister_hook);
 
-static void hnat_sma_build_entry(struct timer_list *t)
+static void hnat_sma_build_entry(unsigned long data)
+//static void hnat_sma_build_entry(struct timer_list *t)
 {
 	int i;
 
@@ -62,7 +63,8 @@ void hnat_cache_ebl(int enable)
 	}
 }
 
-static void hnat_reset_timestamp(struct timer_list *t)
+static void hnat_reset_timestamp(unsigned long data)
+//static void hnat_reset_timestamp(struct timer_list *t)
 {
 	struct foe_entry *entry;
 	int hash_index;
@@ -218,6 +220,7 @@ int entry_delete_by_mac(u8 *mac)
 
 	return ret;
 }
+//TODO:EXPORT_SYMBOL(entry_delete_by_mac);
 
 static void hnat_roam_handler(struct work_struct *work)
 {
@@ -328,6 +331,7 @@ static int hnat_hw_init(u32 ppe_id)
 
 	/* enable FOE */
 	cr_set_bits(hnat_priv->ppe_base[ppe_id] + PPE_FLOW_CFG,
+		    //FIXME:BIT_UDP_IP4F_NAT_EN | BIT_IPV4_NAT_EN | BIT_IPV4_NAPT_EN |
 		    BIT_IPV4_NAT_EN | BIT_IPV4_NAPT_EN |
 		    BIT_IPV4_NAT_FRAG_EN | BIT_IPV4_HASH_GREK |
 		    BIT_IPV4_DSL_EN | BIT_IPV6_6RD_EN |
@@ -357,6 +361,7 @@ static int hnat_hw_init(u32 ppe_id)
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_BND_AGE_1, TCP_DLTA, 7);
 
 	/* setup FOE ka */
+	//FIXME:
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, KA_CFG, 0);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_BIND_LMT_1, NTU_KA, 0);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_KA, KA_T, 0);
@@ -366,6 +371,7 @@ static int hnat_hw_init(u32 ppe_id)
 
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, SCAN_MODE, 2);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, KA_CFG, 3);
+	//FIXME:
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, TICK_SEL, 0);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_KA, KA_T, 1);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_KA, TCP_KA, 1);
@@ -384,6 +390,7 @@ static int hnat_hw_init(u32 ppe_id)
 	writel(0, hnat_priv->ppe_base[ppe_id] + PPE_DFT_CPORT); /* pdma */
 	/* writel(0x55555555, hnat_priv->ppe_base[ppe_id] + PPE_DFT_CPORT); */ /* qdma */
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_GLO_CFG, TTL0_DRP, 0);
+	//FIXME:
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_GLO_CFG, MCAST_TB_EN, 1);
 
 	if (hnat_priv->data->version == MTK_HNAT_V2 ||
@@ -482,6 +489,7 @@ static int ppe_busy_wait(u32 ppe_id)
 			return 0;
 		if (time_after(jiffies, t_start + HZ))
 			break;
+		//usleep_range(10, 20);
 		mdelay(10);
 	}
 
@@ -495,6 +503,8 @@ static void hnat_stop(u32 ppe_id)
 	u32 foe_table_sz;
 	u32 foe_mib_tb_sz;
 	struct foe_entry *entry, *end;
+	u32 r1 = 0, r2 = 0;
+	//TODO:
 
 	if (ppe_id >= CFG_PPE_NUM)
 		return;
@@ -550,6 +560,18 @@ static void hnat_stop(u32 ppe_id)
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, UDP_AGE, 0);
 	cr_set_field(hnat_priv->ppe_base[ppe_id] + PPE_TB_CFG, FIN_AGE, 0);
 
+	r1 = readl(hnat_priv->fe_base + 0x100);
+	r2 = readl(hnat_priv->fe_base + 0x10c);
+
+	dev_info(hnat_priv->dev, "0x100 = 0x%x, 0x10c = 0x%x\n", r1, r2);
+
+	if (((r1 & 0xff00) >> 0x8) >= (r1 & 0xff) ||
+	    ((r1 & 0xff00) >> 0x8) >= (r2 & 0xff)) {
+		dev_info(hnat_priv->dev, "reset pse\n");
+		writel(0x1, hnat_priv->fe_base + 0x4);
+	}
+	//TODO:
+
 	/* free the FOE table */
 	foe_table_sz = hnat_priv->foe_etry_num * sizeof(struct foe_entry);
 	if (hnat_priv->foe_table_cpu[ppe_id])
@@ -602,6 +624,7 @@ int hnat_enable_hook(void)
 {
 	/* register hook functions used by WHNAT module.
 	 */
+	//if (hnat_priv->data->version == MTK_HNAT_V1_2) {
 	if (hnat_priv->data->whnat) {
 		ra_sw_nat_hook_rx =
 			(hnat_priv->data->version == MTK_HNAT_V2 ||
@@ -732,21 +755,21 @@ static int hnat_probe(struct platform_device *pdev)
 
 	err = of_property_read_string(np, "mtketh-lan", &name);
 	if (err < 0)
-		strncpy(hnat_priv->lan, "eth0", IFNAMSIZ);
+		strncpy(hnat_priv->lan, "eth2", IFNAMSIZ);
 	else
 		strncpy(hnat_priv->lan, (char *)name, IFNAMSIZ - 1);
 	dev_info(&pdev->dev, "lan = %s\n", hnat_priv->lan);
 
 	err = of_property_read_string(np, "mtketh-lan2", &name);
 	if (err < 0)
-		strncpy(hnat_priv->lan2, "eth2", IFNAMSIZ);
+		strncpy(hnat_priv->lan2, "eth4", IFNAMSIZ);
 	else
 		strncpy(hnat_priv->lan2, (char *)name, IFNAMSIZ - 1);
 	dev_info(&pdev->dev, "lan2 = %s\n", hnat_priv->lan2);
 
 	err = of_property_read_string(np, "mtketh-ppd", &name);
 	if (err < 0)
-		strncpy(hnat_priv->ppd, "eth0", IFNAMSIZ);
+		strncpy(hnat_priv->ppd, "eth2", IFNAMSIZ);
 	else
 		strncpy(hnat_priv->ppd, (char *)name, IFNAMSIZ - 1);
 	dev_info(&pdev->dev, "ppd = %s\n", hnat_priv->ppd);
@@ -783,6 +806,7 @@ static int hnat_probe(struct platform_device *pdev)
 	if (!res)
 		return -ENOENT;
 
+	//hnat_priv->fe_base = devm_ioremap(&pdev->dev, res->start,
 	hnat_priv->fe_base = devm_ioremap_nocache(&pdev->dev, res->start,
 					     res->end - res->start + 1);
 	if (!hnat_priv->fe_base)
@@ -800,6 +824,9 @@ static int hnat_probe(struct platform_device *pdev)
 	hnat_priv->ppe_base[0] = hnat_priv->fe_base + 0xe00;
 #endif
 
+	//hnat_priv->ipv6_en = true; /* enable ipv6 by default */
+	//hnat_priv->guest_en = true; /* enable guest wifi by default */
+
 	err = hnat_init_debugfs(hnat_priv);
 	if (err)
 		return err;
@@ -848,16 +875,22 @@ static int hnat_probe(struct platform_device *pdev)
 			hnat_mcast_enable(i);
 	}
 
-	timer_setup(&hnat_priv->hnat_sma_build_entry_timer, hnat_sma_build_entry, 0);
+	init_timer(&hnat_priv->hnat_sma_build_entry_timer);
+	hnat_priv->hnat_sma_build_entry_timer.function = hnat_sma_build_entry;
+	//timer_setup(&hnat_priv->hnat_sma_build_entry_timer, hnat_sma_build_entry, 0);
 	if (hnat_priv->data->version == MTK_HNAT_V1_3) {
-		timer_setup(&hnat_priv->hnat_reset_timestamp_timer, hnat_reset_timestamp, 0);
+		init_timer(&hnat_priv->hnat_reset_timestamp_timer);
+		hnat_priv->hnat_reset_timestamp_timer.function = hnat_reset_timestamp;
+		//timer_setup(&hnat_priv->hnat_reset_timestamp_timer, hnat_reset_timestamp, 0);
 		hnat_priv->hnat_reset_timestamp_timer.expires = jiffies;
 		add_timer(&hnat_priv->hnat_reset_timestamp_timer);
 	}
 
+	//if (qos_toggle && IS_GMAC1_MODE)
 	if (IS_HQOS_MODE && IS_GMAC1_MODE)
 		dev_add_pack(&mtk_pack_type);
 
+	//FIXME:
 	err = hnat_roaming_enable();
 	if (err)
 		pr_info("hnat roaming work fail\n");
@@ -883,6 +916,7 @@ static int hnat_remove(struct platform_device *pdev)
 {
 	int i;
 
+	//FIXME:
 	hnat_roaming_disable();
 	unregister_netdevice_notifier(&nf_hnat_netdevice_nb);
 	unregister_netevent_notifier(&nf_hnat_netevent_nb);
@@ -900,6 +934,7 @@ static int hnat_remove(struct platform_device *pdev)
 	if (hnat_priv->data->version == MTK_HNAT_V1_3)
 		del_timer_sync(&hnat_priv->hnat_reset_timestamp_timer);
 
+	//if (qos_toggle && IS_GMAC1_MODE)
 	if (IS_HQOS_MODE && IS_GMAC1_MODE)
 		dev_remove_pack(&mtk_pack_type);
 
@@ -909,6 +944,7 @@ static int hnat_remove(struct platform_device *pdev)
 static const struct mtk_hnat_data hnat_data_v1 = {
 	.num_of_sch = 2,
 	.whnat = false,
+	//TODO:.whnat = true,
 	.per_flow_accounting = false,
 	.mcast = false,
 	.version = MTK_HNAT_V1_1,
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.h b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.h
index 8f5f37b3..0a74791e 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.h
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat.h
@@ -16,7 +16,8 @@
 #include <linux/if.h>
 #include <linux/if_ether.h>
 #include <net/netevent.h>
-#include <linux/mod_devicetable.h>
+#include <net/netfilter/nf_hnat.h>
+//#include <linux/mod_devicetable.h>
 #include "hnat_mcast.h"
 #include "nf_hnat_mtk.h"
 
@@ -109,6 +110,11 @@
 #define GDMA3_FWD_CFG 0x540
 
 /* QDMA Tx queue configuration */
+#if defined(CONFIG_MEDIATEK_NETSYS_V2)
+#define QDMA_BASE               0x4400
+#else
+#define QDMA_BASE               0x1800
+#endif
 #define QTX_CFG(x)			(QDMA_BASE + ((x) * 0x10))
 #define QTX_CFG_HW_RESV_CNT_OFFSET	(8)
 #define QTX_CFG_SW_RESV_CNT_OFFSET	(0)
@@ -556,6 +562,7 @@ struct hnat_ipv6_3t_route {
 	u32 ipv6_dip2;
 	u32 ipv6_dip3;
 	u32 prot : 8;
+	//u32 resv : 24;
 	u32 hph : 24; /* hash placeholder */
 
 	u32 resv1;
@@ -802,8 +809,10 @@ struct foe_entry {
 /* If user wants to change default FOE entry number, both DEF_ETRY_NUM and
  * DEF_ETRY_NUM_CFG need to be modified.
  */
+//#define DEF_ETRY_NUM		16384
 #define DEF_ETRY_NUM		8192
 /* feasible values : 32768, 16384, 8192, 4096, 2048, 1024 */
+//#define DEF_ETRY_NUM_CFG	TABLE_16K
 #define DEF_ETRY_NUM_CFG	TABLE_8K
 /* corresponding values : TABLE_32K, TABLE_16K, TABLE_8K, TABLE_4K, TABLE_2K,
  * TABLE_1K
@@ -904,6 +913,8 @@ struct mtk_hnat {
 	struct timer_list hnat_mcast_check_timer;
 	bool nf_stat_en;
 	struct xlat_conf xlat;
+	//bool ipv6_en;
+	//bool guest_en;
 };
 
 struct extdev_entry {
@@ -925,8 +936,13 @@ enum FoeIpAct {
 	IPV6_3T_ROUTE = 4,
 	IPV6_5T_ROUTE = 5,
 	IPV6_6RD = 7,
+//TODO:#if defined(CONFIG_MEDIATEK_NETSYS_V2) || defined(CONFIG_MEDIATEK_NETSYS_V3)
 	IPV4_MAP_T = 8,
 	IPV4_MAP_E = 9,
+/*#else
+	IPV4_MAP_T = 6,
+	IPV4_MAP_E = 6,
+#endif*/
 	IPV6_HNAPT = 10,
 	IPV6_HNAT = 11,
 };
@@ -942,6 +958,7 @@ enum FoeIpAct {
 #define ENTRY_128B 0
 #define ENTRY_96B 1
 #define ENTRY_80B 1
+#define ENTRY_64B 0
 #define TABLE_1K 0
 #define TABLE_2K 1
 #define TABLE_4K 2
@@ -961,6 +978,7 @@ enum FoeIpAct {
 #define BIT_FUC_FOE BIT(2)
 #define BIT_FMC_FOE BIT(1)
 #define BIT_FBC_FOE BIT(0)
+#define BIT_TCP_IP4F_NAT_EN BIT(6)
 #define BIT_UDP_IP4F_NAT_EN BIT(7) /*Enable IPv4 fragment + UDP packet NAT*/
 #define BIT_IPV6_3T_ROUTE_EN BIT(8)
 #define BIT_IPV6_5T_ROUTE_EN BIT(9)
@@ -1094,6 +1112,8 @@ enum FoeIpAct {
 #define IS_LAN2(dev) (!strncmp(dev->name, LAN2_DEV_NAME,			\
 		      strlen(LAN2_DEV_NAME)))
 #define IS_BR(dev) (!strncmp(dev->name, "br", 2))
+/*#define IS_WHNAT(dev)							       \
+	((hnat_priv->data->version == MTK_HNAT_V1_2 &&			       \*/
 #define IS_WHNAT(dev)								\
 	((hnat_priv->data->whnat &&						\
 	 (get_wifi_hook_if_index_from_dev(dev) != 0)) ? 1 : 0)
@@ -1114,6 +1134,7 @@ enum FoeIpAct {
 	(IS_IPV6_3T_ROUTE(x) | IS_IPV6_5T_ROUTE(x) | IS_IPV6_6RD(x) |          \
 	 IS_IPV4_DSLITE(x) | IS_IPV4_MAPE(x) | IS_IPV4_MAPT(x) |	       \
 	 IS_IPV6_HNAPT(x) | IS_IPV6_HNAT(x))
+//FIXME:	 IS_IPV4_DSLITE(x))
 #define IS_BOND_MODE (!strncmp(LAN_DEV_NAME, "bond", 4))
 #define IS_GMAC1_MODE ((hnat_priv->gmac_num == 1) ? 1 : 0)
 #define IS_HQOS_MODE (qos_toggle == 1)
@@ -1171,7 +1192,10 @@ extern struct mtk_hnat *hnat_priv;
 #if defined(CONFIG_NET_DSA_MT7530)
 u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 		       struct foe_entry *entry,
-		       struct flow_offload_hw_path *hw_path,
+		       struct hnat_hw_path *hw_path,
+		       //struct net_device_path_ctx *ctx,
+		       //struct net_device_path *hw_path,
+		       //struct flow_offload_hw_path *hw_path,
 		       u16 eth_proto, int mape);
 
 static inline bool hnat_dsa_is_enable(struct mtk_hnat *priv)
@@ -1181,7 +1205,10 @@ static inline bool hnat_dsa_is_enable(struct mtk_hnat *priv)
 #else
 static inline u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 				     struct foe_entry *entry,
-				     struct flow_offload_hw_path *hw_path,
+				     struct hnat_hw_path *hw_path,
+				     //struct net_device_path_ctx *ctx,
+				     //struct net_device_path *hw_path,
+				     //struct flow_offload_hw_path *hw_path,
 				     u16 eth_proto, int mape)
 {
 	return 0;
@@ -1194,6 +1221,7 @@ static inline bool hnat_dsa_is_enable(struct mtk_hnat *priv)
 #endif
 
 void hnat_deinit_debugfs(struct mtk_hnat *h);
+//int __init hnat_init_debugfs(struct mtk_hnat *h);
 int hnat_init_debugfs(struct mtk_hnat *h);
 int hnat_register_nf_hooks(void);
 void hnat_unregister_nf_hooks(void);
@@ -1230,7 +1258,8 @@ void hnat_qos_shaper_ebl(u32 id, u32 enable);
 void set_gmac_ppe_fwd(int gmac_no, int enable);
 int entry_detail(u32 ppe_id, int index);
 int entry_delete_by_mac(u8 *mac);
-int entry_delete(u32 ppe_id, int index);
+int entry_delete(int index);
+//TODO:int entry_delete(u32 ppe_id, int index);
 int hnat_warm_init(void);
 u32 hnat_get_ppe_hash(struct foe_entry *entry);
 int mtk_ppe_get_xlat_v4_by_v6(struct in6_addr *ipv6, u32 *ipv4);
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_debugfs.c b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_debugfs.c
index 96d446e7..f1e2ef00 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_debugfs.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_debugfs.c
@@ -371,6 +371,7 @@ int entry_detail(u32 ppe_id, int index)
 	pr_info("==========<PPE_ID=%d, Flow Table Entry=%d (%p)>===============\n",
 		ppe_id, index, entry);
 	if (debug_level >= 2) {
+		//print_cnt = 32;
 		print_cnt = 20;
 		for (i = 0; i < print_cnt; i++)
 			pr_info("%02d: %08X\n", i, *(p + i));
@@ -630,19 +631,22 @@ int entry_detail(u32 ppe_id, int index)
 }
 
 int wrapped_ppe0_entry_delete(int index) {
-	entry_delete(0, index);
+	entry_delete(index);
+	//TODO:entry_delete(0, index);
 	return 0;
 }
 
 int wrapped_ppe1_entry_delete(int index) {
-	entry_delete(1, index);
+	//TODO:entry_delete(1, index);
 	return 0;
 }
 
-int entry_delete(u32 ppe_id, int index)
+int entry_delete(int index)
+//TODO:int entry_delete(u32 ppe_id, int index)
 {
 	struct foe_entry *entry;
 	struct mtk_hnat *h = hnat_priv;
+	u32 ppe_id = 0;
 
 	if (ppe_id >= CFG_PPE_NUM)
 		return -EINVAL;
@@ -684,7 +688,9 @@ int cr_set_usage(int level)
 	pr_info("              4     0~65535    Set UDP bind lifetime\n");
 	pr_info("              5     0~255      Set TCP keep alive interval\n");
 	pr_info("              6     0~255      Set UDP keep alive interval\n");
-	pr_info("              7     0~1        Set hnat counter update to nf_conntrack\n");
+	pr_info("              8     0~1        Set hnat counter update to nf_conntrack\n");
+	pr_info("              7     0~1        Set hnat disable/enable ipv6\n");
+	pr_info("              9     0~1        Set hnat disable/enable guest (rax1/rai1/ra1)\n");
 
 	return 0;
 }
@@ -796,6 +802,57 @@ int set_nf_update_toggle(int toggle)
 	return 0;
 }
 
+int set_ipv6_toggle(int toggle)
+{
+	struct mtk_hnat *h = hnat_priv;
+
+	if (toggle == 1)
+		pr_info("Enable hnat ipv6\n");
+	else if (toggle == 0)
+		pr_info("Disable hnat ipv6\n");
+	else {
+		pr_info("input error, current ipv6_en=%d\n", h->ipv6_en);
+		return 0;
+	}
+	h->ipv6_en = toggle;
+
+	return 0;
+}
+
+void mtk_ppe_dev_hook(const char *name, int toggle)
+{
+	struct net_device *dev;
+	dev = dev_get_by_name(&init_net, name);
+	if (dev) {
+		if (toggle) {
+			mtk_ppe_dev_register_hook(dev);
+		} else {
+			mtk_ppe_dev_unregister_hook(dev);
+		}
+	}
+	return;
+}
+
+int set_guest_toggle(int toggle)
+{
+	struct mtk_hnat *h = hnat_priv;
+
+	if (toggle == 1)
+		pr_info("Enable hnat guest interface\n");
+	else if (toggle == 0)
+		pr_info("Disable hnat guest interface\n");
+	else {
+		pr_info("input error, current guest_en=%d\n", h->guest_en);
+		return 0;
+	}
+	h->guest_en = toggle;
+
+	mtk_ppe_dev_hook("ra1", toggle);
+	mtk_ppe_dev_hook("rai1", toggle);
+	mtk_ppe_dev_hook("rax1", toggle);
+	return 0;
+}
+
 static const debugfs_write_func hnat_set_func[] = {
 	[0] = hnat_set_usage,
 	[1] = hnat_cpu_reason,
@@ -814,7 +871,8 @@ static const debugfs_write_func cr_set_func[] = {
 	[0] = cr_set_usage,      [1] = binding_threshold,
 	[2] = tcp_bind_lifetime, [3] = fin_bind_lifetime,
 	[4] = udp_bind_lifetime, [5] = tcp_keep_alive,
-	[6] = udp_keep_alive,    [7] = set_nf_update_toggle,
+	[6] = udp_keep_alive,    [8] = set_nf_update_toggle,
+	[7] = set_ipv6_toggle,   [9] = set_guest_toggle,
 };
 
 int read_mib(struct mtk_hnat *h, u32 ppe_id,
@@ -880,7 +938,7 @@ struct hnat_accounting *hnat_get_count(struct mtk_hnat *h, u32 ppe_id,
 
 	return &h->acct[ppe_id][index];
 }
-EXPORT_SYMBOL(hnat_get_count);
+//TODO:EXPORT_SYMBOL(hnat_get_count);
 
 #define PRINT_COUNT(m, acct) {if (acct) \
 		seq_printf(m, "bytes=%llu|packets=%llu|", \
@@ -1323,6 +1381,7 @@ static ssize_t hnat_whnat_write(struct file *file, const char __user *buf,
 			mtk_ppe_dev_unregister_hook(dev);
 			pr_info("unregister wifi extern if = %s\n", dev->name);
 		}
+		//FIXME:
 		dev_put(dev);
 	} else {
 		pr_info("no such device!\n");
@@ -1339,6 +1398,7 @@ static const struct file_operations hnat_whnat_fops = {
 	.open = hnat_whnat_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
+	//FIXME:
 	.write = hnat_whnat_write,
 	.release = single_release,
 };
@@ -1823,6 +1883,8 @@ ssize_t hnat_setting_write(struct file *file, const char __user *buffer,
 	case 5:
 	case 6:
 	case 7:
+	case 8:
+	case 9:
 		p_token = strsep(&p_buf, p_delimiter);
 		if (!p_token)
 			arg1 = 0;
@@ -2176,6 +2238,7 @@ static ssize_t hnat_queue_write(struct file *file, const char __user *buf,
 	u32 qtx_sch = 0;
 
 	cr_set_field(h->fe_base + QDMA_PAGE, QTX_CFG_PAGE, (id / NUM_OF_Q_PER_PAGE));
+	//FIXME:qtx_sch = readl(h->fe_base + QTX_SCH(id % NUM_OF_Q_PER_PAGE));
 	if (length >= sizeof(line))
 		return -EINVAL;
 
@@ -2207,6 +2270,7 @@ static ssize_t hnat_queue_write(struct file *file, const char __user *buf,
 		min_exp++;
 	}
 
+	//FIXME:qtx_sch &= 0x70000000;
 	if (hnat_priv->data->num_of_sch == 4)
 		qtx_sch |= (scheduler & 0x3) << 30;
 	else
@@ -2678,16 +2742,23 @@ static void hnat_qos_disable(void)
 
 	for (id = 0; id < MAX_PPPQ_PORT_NUM; id++) {
 		hnat_qos_shaper_ebl(id, 0);
+		//writel(0, h->fe_base + QTX_CFG(id % NUM_OF_Q_PER_PAGE));
 		writel((4 << QTX_CFG_HW_RESV_CNT_OFFSET) |
 		       (4 << QTX_CFG_SW_RESV_CNT_OFFSET),
 		       h->fe_base + QTX_CFG(id % NUM_OF_Q_PER_PAGE));
 	}
 
+	/*writel((4 << QTX_CFG_HW_RESV_CNT_OFFSET) |
+	       (4 << QTX_CFG_SW_RESV_CNT_OFFSET), h->fe_base + QTX_CFG(0));*/
+
+	//FIXME:
 	cfg = (QDMA_TX_SCH_WFQ_EN) | (QDMA_TX_SCH_WFQ_EN << 16);
 	for (id = 0; id < h->data->num_of_sch; id += 2) {
 		if (h->data->num_of_sch == 4)
+			//writel(0, h->fe_base + QDMA_TX_4SCH_BASE(id));
 			writel(cfg, h->fe_base + QDMA_TX_4SCH_BASE(id));
 		else
+			//writel(0, h->fe_base + QDMA_TX_2SCH_BASE);
 			writel(cfg, h->fe_base + QDMA_TX_2SCH_BASE);
 	}
 }
@@ -2708,11 +2779,14 @@ static void hnat_qos_pppq_enable(void)
 		       h->fe_base + QTX_CFG(id % NUM_OF_Q_PER_PAGE));
 	}
 
+	//TODO:
 	cfg = (QDMA_TX_SCH_WFQ_EN) | (QDMA_TX_SCH_WFQ_EN << 16);
 	for (id = 0; id < h->data->num_of_sch; id+= 2) {
 		if (h->data->num_of_sch == 4)
+                        //writel(0, h->fe_base + QDMA_TX_4SCH_BASE(id));
                         writel(cfg, h->fe_base + QDMA_TX_4SCH_BASE(id));
                 else
+                        //writel(0, h->fe_base + QDMA_TX_2SCH_BASE);
                         writel(cfg, h->fe_base + QDMA_TX_2SCH_BASE);
 	}
 }
@@ -3016,11 +3090,13 @@ static const struct file_operations hnat_static_fops = {
 	.release = single_release,
 };
 
-int get_ppe_mib(u32 ppe_id, int index, u64 *pkt_cnt, u64 *byte_cnt)
+int get_ppe_mib(int index, u64 *pkt_cnt, u64 *byte_cnt)
+//TODO:int get_ppe_mib(u32 ppe_id, int index, u64 *pkt_cnt, u64 *byte_cnt)
 {
 	struct mtk_hnat *h = hnat_priv;
 	struct hnat_accounting *acct;
 	struct foe_entry *entry;
+	u32 ppe_id = 0;
 
 	if (ppe_id >= CFG_PPE_NUM)
 		return -EINVAL;
@@ -3046,10 +3122,12 @@ int get_ppe_mib(u32 ppe_id, int index, u64 *pkt_cnt, u64 *byte_cnt)
 }
 EXPORT_SYMBOL(get_ppe_mib);
 
-int is_entry_binding(u32 ppe_id, int index)
+int is_entry_binding(int index)
+//TODO:int is_entry_binding(u32 ppe_id, int index)
 {
 	struct mtk_hnat *h = hnat_priv;
 	struct foe_entry *entry;
+	u32 ppe_id = 0;
 
 	if (ppe_id >= CFG_PPE_NUM)
 		return -EINVAL;
@@ -3137,6 +3215,7 @@ int hnat_init_debugfs(struct mtk_hnat *h)
 			ret = -ENOMEM;
 			goto err1;
 		}
+		//file = debugfs_create_regset32("regdump", S_IRUGO, root, h->regset);
 		file = debugfs_create_regset32(name, 0444,
 					       root, h->regset[i]);
 		if (!file) {
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_mcast.c b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_mcast.c
index edf17cb4..5dc2813e 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_mcast.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_mcast.c
@@ -256,7 +256,8 @@ out:
 	return NULL;
 }
 
-static void hnat_mcast_check_timestamp(struct timer_list *t)
+static void hnat_mcast_check_timestamp(unsigned long data)
+//static void hnat_mcast_check_timestamp(struct timer_list *t)
 {
 	struct foe_entry *entry;
 	int i, hash_index;
@@ -271,7 +272,8 @@ static void hnat_mcast_check_timestamp(struct timer_list *t)
 				if ((foe_ts - e_ts) > 0x3000)
 					foe_ts = (~(foe_ts)) & 0xffff;
 				if (abs(foe_ts - e_ts) > 20)
-					entry_delete(i, hash_index);
+					entry_delete(hash_index);
+					//TODO:entry_delete(i, hash_index);
 			}
 		}
 	}
@@ -307,8 +309,11 @@ int hnat_mcast_enable(u32 ppe_id)
 
 	/* mt7629 should checkout mcast entry life time manualy */
 	if (hnat_priv->data->version == MTK_HNAT_V1_3) {
-		timer_setup(&hnat_priv->hnat_mcast_check_timer,
-			    hnat_mcast_check_timestamp, 0);
+		init_timer(&hnat_priv->hnat_mcast_check_timer);
+		hnat_priv->hnat_mcast_check_timer.function =
+			hnat_mcast_check_timestamp;
+		/*timer_setup(&hnat_priv->hnat_mcast_check_timer,
+			    hnat_mcast_check_timestamp, 0);*/
 		hnat_priv->hnat_mcast_check_timer.expires = jiffies;
 		add_timer(&hnat_priv->hnat_mcast_check_timer);
 	}
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c
index 05f49558..af01600d 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_nf_hook.c
@@ -14,10 +14,11 @@
 #include <linux/netfilter_bridge.h>
 #include <linux/netfilter_ipv6.h>
 
+#include <linux/of.h>
 #include <net/arp.h>
 #include <net/neighbour.h>
 #include <net/netfilter/nf_conntrack_helper.h>
-#include <net/netfilter/nf_flow_table.h>
+//#include <net/netfilter/nf_flow_table.h>
 #include <net/ipv6.h>
 #include <net/ip6_route.h>
 #include <net/ip.h>
@@ -30,7 +31,7 @@
 #include "hnat.h"
 
 #include "../mtk_eth_soc.h"
-#include "../mtk_eth_reset.h"
+//#include "../mtk_eth_reset.h"
 
 #define do_ge2ext_fast(dev, skb)                                               \
 	((IS_LAN_GRP(dev) || IS_WAN(dev) || IS_PPD(dev)) && \
@@ -191,7 +192,8 @@ void foe_clear_all_bind_entries(struct net_device *dev)
 
 	if (!IS_LAN_GRP(dev) && !IS_WAN(dev) &&
 	    !find_extif_from_devname(dev->name) &&
-	    !dev->netdev_ops->ndo_flow_offload_check)
+	    !dev->netdev_ops->ndo_hnat_check)
+	    //!dev->netdev_ops->ndo_flow_offload_check)
 		return;
 
 	for (i = 0; i < CFG_PPE_NUM; i++) {
@@ -233,6 +235,11 @@ int nf_hnat_netdevice_event(struct notifier_block *unused, unsigned long event,
 
 	switch (event) {
 	case NETDEV_UP:
+		/*TODO:if (!hnat_priv->guest_en && dev->name) {
+			if (!strcmp(dev->name, "ra1") || !strcmp(dev->name, "rai1") || !strcmp(dev->name, "rax1"))
+				break;
+		}*/
+
 		gmac_ppe_fwd_enable(dev);
 
 		extif_set_dev(dev);
@@ -246,10 +253,12 @@ int nf_hnat_netdevice_event(struct notifier_block *unused, unsigned long event,
 
 		break;
 	case NETDEV_UNREGISTER:
+		//if (IS_PPD(dev) && hnat_priv->g_ppdev) {
 		if (hnat_priv->g_ppdev == dev) {
 			hnat_priv->g_ppdev = NULL;
 			dev_put(dev);
 		}
+		//if (IS_WAN(dev) && hnat_priv->g_wandev) {
 		if (hnat_priv->g_wandev == dev) {
 			hnat_priv->g_wandev = NULL;
 			dev_put(dev);
@@ -263,10 +272,10 @@ int nf_hnat_netdevice_event(struct notifier_block *unused, unsigned long event,
 			hnat_priv->g_wandev = dev_get_by_name(&init_net, hnat_priv->wan);
 
 		break;
-	case MTK_FE_RESET_NAT_DONE:
+	/*TODO:case MTK_FE_RESET_NAT_DONE:
 		pr_info("[%s] HNAT driver starts to do warm init !\n", __func__);
 		hnat_warm_init();
-		break;
+		break;*/
 	default:
 		break;
 	}
@@ -290,13 +299,16 @@ void foe_clear_entry(struct neighbour *neigh)
 
 		for (hash_index = 0; hash_index < hnat_priv->foe_etry_num; hash_index++) {
 			entry = hnat_priv->foe_table_cpu[i] + hash_index;
+			/*if (entry->bfib1.state == BIND &&
+			    entry->ipv4_hnapt.new_dip == ntohl(dip)) {*/
 			if (entry->bfib1.state == BIND &&
 			    entry->ipv4_hnapt.new_dip == ntohl(dip) &&
 			    IS_IPV4_HNAPT(entry)) {
 				*((u32 *)h_dest) = swab32(entry->ipv4_hnapt.dmac_hi);
 				*((u16 *)&h_dest[4]) =
 					swab16(entry->ipv4_hnapt.dmac_lo);
-				if (strncmp(h_dest, neigh->ha, ETH_ALEN) != 0) {
+				if (!ether_addr_equal(h_dest, neigh->ha)) {
+				//TODO:if (strncmp(h_dest, neigh->ha, ETH_ALEN) != 0) {
 					pr_info("%s: state=%d\n", __func__,
 						neigh->nud_state);
 					cr_set_field(hnat_priv->ppe_base[i] + PPE_TB_CFG,
@@ -396,9 +408,10 @@ unsigned int do_hnat_ext_to_ge(struct sk_buff *skb, const struct net_device *in,
 		}
 
 		/*set where we come from*/
-		skb->vlan_proto = htons(ETH_P_8021Q);
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), in->ifindex & VLAN_VID_MASK);
+		/*skb->vlan_proto = htons(ETH_P_8021Q);
 		skb->vlan_tci =
-			(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));
+			(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));*/
 		trace_printk(
 			"%s: vlan_prot=0x%x, vlan_tci=%x, in->name=%s, skb->dev->name=%s\n",
 			__func__, ntohs(skb->vlan_proto), skb->vlan_tci,
@@ -504,6 +517,7 @@ unsigned int do_hnat_ge_to_ext(struct sk_buff *skb, const char *func)
 
 	skb->dev = dev;
 
+	//if (qos_toggle && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 	if (IS_HQOS_MODE && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 		skb = skb_unshare(skb, GFP_ATOMIC);
 		if (!skb)
@@ -597,8 +611,11 @@ static inline void hnat_set_iif(const struct nf_hook_state *state,
 		skb_hnat_iface(skb) = FOE_MAGIC_EXT;
 	} else if (IS_WAN(state->in)) {
 		skb_hnat_iface(skb) = FOE_MAGIC_GE_WAN;
+	/*FIXME:} else if (state->in->netdev_ops->ndo_hnat_check) {
+		skb_hnat_iface(skb) = FOE_MAGIC_GE_VIRTUAL;*/
 	} else if (!IS_BR(state->in)) {
-		if (state->in->netdev_ops->ndo_flow_offload_check) {
+		if (state->in->netdev_ops->ndo_hnat_check) {
+		//if (state->in->netdev_ops->ndo_flow_offload_check) {
 			skb_hnat_iface(skb) = FOE_MAGIC_GE_VIRTUAL;
 		} else {
 			skb_hnat_iface(skb) = FOE_INVALID;
@@ -672,9 +689,10 @@ unsigned int do_hnat_mape_w2l_fast(struct sk_buff *skb, const struct net_device
 		eth->h_proto = htons(ETH_P_IP);
 		set_to_ppe(skb);
 
-		skb->vlan_proto = htons(ETH_P_8021Q);
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), in->ifindex & VLAN_VID_MASK);
+		/*skb->vlan_proto = htons(ETH_P_8021Q);
 		skb->vlan_tci =
-		(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));
+		(VLAN_CFI_MASK | (in->ifindex & VLAN_VID_MASK));*/
 
 		if (!hnat_priv->g_ppdev)
 			hnat_priv->g_ppdev = dev_get_by_name(&init_net, hnat_priv->ppd);
@@ -708,6 +726,75 @@ void mtk_464xlat_pre_process(struct sk_buff *skb)
 		       sizeof(struct hnat_desc));
 }
 
+#if defined(CONFIG_MEDIATEK_NETSYS_V2)
+unsigned int do_hnat_mape_w2l(struct sk_buff *skb, const struct net_device *in,
+				   const char *func)
+{
+	struct ipv6hdr *ip6h = ipv6_hdr(skb);
+	struct iphdr _iphdr;
+	struct iphdr *iph;
+	struct foe_entry *entry;
+	struct tcpudphdr _ports;
+	const struct tcpudphdr *pptr;
+	int udp = 0;
+
+	/* WAN -> LAN/WLAN MapE learn info(include innner IPv4 header info). */
+	if (ip6h->nexthdr == NEXTHDR_IPIP) {
+		entry = &hnat_priv->foe_table_cpu[skb_hnat_ppe(skb)][skb_hnat_entry(skb)];
+
+		entry->ipv4_dslite.tunnel_sipv6_0 =
+			ntohl(ip6h->saddr.s6_addr32[0]);
+		entry->ipv4_dslite.tunnel_sipv6_1 =
+			ntohl(ip6h->saddr.s6_addr32[1]);
+		entry->ipv4_dslite.tunnel_sipv6_2 =
+			ntohl(ip6h->saddr.s6_addr32[2]);
+		entry->ipv4_dslite.tunnel_sipv6_3 =
+			ntohl(ip6h->saddr.s6_addr32[3]);
+
+		entry->ipv4_dslite.tunnel_dipv6_0 =
+			ntohl(ip6h->daddr.s6_addr32[0]);
+		entry->ipv4_dslite.tunnel_dipv6_1 =
+			ntohl(ip6h->daddr.s6_addr32[1]);
+		entry->ipv4_dslite.tunnel_dipv6_2 =
+			ntohl(ip6h->daddr.s6_addr32[2]);
+		entry->ipv4_dslite.tunnel_dipv6_3 =
+			ntohl(ip6h->daddr.s6_addr32[3]);
+
+		ppe_fill_flow_lbl(entry, ip6h);
+
+		iph = skb_header_pointer(skb, IPV6_HDR_LEN,
+					 sizeof(_iphdr), &_iphdr);
+		if (unlikely(!iph))
+			return NF_ACCEPT;
+
+		switch (iph->protocol) {
+		case IPPROTO_UDP:
+			udp = 1;
+		case IPPROTO_TCP:
+		break;
+
+		default:
+			return NF_ACCEPT;
+		}
+
+		pptr = skb_header_pointer(skb, IPV6_HDR_LEN + iph->ihl * 4,
+					  sizeof(_ports), &_ports);
+		if (unlikely(!pptr))
+			return NF_ACCEPT;
+
+		entry->bfib1.udp = udp;
+
+		entry->ipv4_dslite.new_sip = ntohl(iph->saddr);
+		entry->ipv4_dslite.new_dip = ntohl(iph->daddr);
+		entry->ipv4_dslite.new_sport = ntohs(pptr->src);
+		entry->ipv4_dslite.new_dport = ntohs(pptr->dst);
+
+		return 0;
+	}
+	return -1;
+}
+#endif
+
 static unsigned int is_ppe_support_type(struct sk_buff *skb)
 {
 	struct ethhdr *eth = NULL;
@@ -716,6 +803,9 @@ static unsigned int is_ppe_support_type(struct sk_buff *skb)
 	struct iphdr _iphdr;
 
 	eth = eth_hdr(skb);
+	//FIXME:if (is_broadcast_ether_addr(eth->h_dest))
+	/*if (!is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb) ||
+	    is_multicast_ether_addr(eth->h_dest))*/
 	if (!is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb) ||
 	    is_broadcast_ether_addr(eth->h_dest))
 		return 0;
@@ -795,10 +885,15 @@ mtk_hnat_ipv6_nf_pre_routing(void *priv, struct sk_buff *skb,
 #if !(defined(CONFIG_MEDIATEK_NETSYS_V2) || defined(CONFIG_MEDIATEK_NETSYS_V3))
 	/* MapE need remove ipv6 header and pingpong. */
 	if (do_mape_w2l_fast(state->in, skb)) {
+#if defined(CONFIG_MEDIATEK_NETSYS_V2)
+		if (mape_toggle && do_hnat_mape_w2l(skb, state->in, __func__))
+			return NF_ACCEPT;
+#else
 		if (!do_hnat_mape_w2l_fast(skb, state->in, __func__))
 			return NF_STOLEN;
 		else
 			return NF_ACCEPT;
+#endif
 	}
 
 	if (is_from_mape(skb))
@@ -825,8 +920,8 @@ static unsigned int
 mtk_hnat_ipv4_nf_pre_routing(void *priv, struct sk_buff *skb,
 			     const struct nf_hook_state *state)
 {
-	struct flow_offload_hw_path hw_path = { .dev = skb->dev,
-						.virt_dev = skb->dev };
+	/*TODO:struct flow_offload_hw_path hw_path = { .dev = skb->dev,
+						.virt_dev = skb->dev };*/
 
 	if (!skb)
 		goto drop;
@@ -843,13 +938,13 @@ mtk_hnat_ipv4_nf_pre_routing(void *priv, struct sk_buff *skb,
 	 * In pre-routing, if dev is virtual iface, TOPS module is not loaded,
 	 * and it's L2TP flow, then do not bind.
 	 */
-	if (skb_hnat_iface(skb) == FOE_MAGIC_GE_VIRTUAL
+	/*TODO:if (skb_hnat_iface(skb) == FOE_MAGIC_GE_VIRTUAL
 	    && skb->dev->netdev_ops->ndo_flow_offload_check) {
 		skb->dev->netdev_ops->ndo_flow_offload_check(&hw_path);
 
 		if (hw_path.flags & FLOW_OFFLOAD_PATH_TNL)
 			skb_hnat_alg(skb) = 1;
-	}
+	}*/
 
 	pre_routing_print(skb, state->in, state->out, __func__);
 
@@ -894,6 +989,7 @@ mtk_hnat_br_nf_local_in(void *priv, struct sk_buff *skb,
 	if (!skb)
 		goto drop;
 
+	//if (qos_toggle && hnat_priv->data->whnat) {
 	if (IS_HQOS_MODE && hnat_priv->data->whnat) {
 		veth = (struct vlan_ethhdr *)skb_mac_header(skb);
 
@@ -974,15 +1070,18 @@ drop:
 
 static unsigned int hnat_ipv6_get_nexthop(struct sk_buff *skb,
 					  const struct net_device *out,
-					  struct flow_offload_hw_path *hw_path)
+					  struct hnat_hw_path *hw_path)
+					  //struct flow_offload_hw_path *hw_path)
 {
-	const struct in6_addr *ipv6_nexthop;
+	struct in6_addr *ipv6_nexthop;
+	//const struct in6_addr *ipv6_nexthop;
 	struct neighbour *neigh = NULL;
 	struct dst_entry *dst = skb_dst(skb);
 	struct ethhdr *eth;
 	u16 eth_pppoe_hlen = ETH_HLEN + PPPOE_SES_HLEN;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
+	if (hw_path->flags & HNAT_PATH_PPPOE) {
+	//if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
 		if (ipv6_hdr(skb)->nexthdr == NEXTHDR_IPIP) {
 			eth = (struct ethhdr *)(skb->data - eth_pppoe_hlen);
 			eth->h_proto = skb->protocol;
@@ -1032,7 +1131,8 @@ static unsigned int hnat_ipv6_get_nexthop(struct sk_buff *skb,
 
 static unsigned int hnat_ipv4_get_nexthop(struct sk_buff *skb,
 					  const struct net_device *out,
-					  struct flow_offload_hw_path *hw_path)
+					  struct hnat_hw_path *hw_path)
+					  //struct flow_offload_hw_path *hw_path)
 {
 	u32 nexthop;
 	struct neighbour *neigh;
@@ -1040,7 +1140,8 @@ static unsigned int hnat_ipv4_get_nexthop(struct sk_buff *skb,
 	struct rtable *rt = (struct rtable *)dst;
 	struct net_device *dev = (__force struct net_device *)out;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
+	if (hw_path->flags & HNAT_PATH_PPPOE) {
+	//if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) {
 		memcpy(eth_hdr(skb)->h_source, hw_path->eth_src, ETH_ALEN);
 		memcpy(eth_hdr(skb)->h_dest, hw_path->eth_dest, ETH_ALEN);
 		return 0;
@@ -1091,7 +1192,8 @@ static u16 ppe_get_chkbase(struct iphdr *iph)
 }
 
 struct foe_entry ppe_fill_L2_info(struct ethhdr *eth, struct foe_entry entry,
-				  struct flow_offload_hw_path *hw_path)
+				  struct hnat_hw_path *hw_path)
+				  //struct flow_offload_hw_path *hw_path)
 {
 	switch ((int)entry.bfib1.pkt_type) {
 	case IPV4_HNAPT:
@@ -1101,6 +1203,8 @@ struct foe_entry ppe_fill_L2_info(struct ethhdr *eth, struct foe_entry entry,
 		entry.ipv4_hnapt.smac_hi = swab32(*((u32 *)eth->h_source));
 		entry.ipv4_hnapt.smac_lo = swab16(*((u16 *)&eth->h_source[4]));
 		entry.ipv4_hnapt.pppoe_id = hw_path->pppoe_sid;
+		/*entry.ipv4_hnapt.pppoe_id = (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) ?
+					     hw_path->encap.id : 0;*/
 		break;
 	case IPV4_DSLITE:
 	case IPV4_MAP_E:
@@ -1115,18 +1219,25 @@ struct foe_entry ppe_fill_L2_info(struct ethhdr *eth, struct foe_entry entry,
 		entry.ipv6_5t_route.smac_lo =
 			swab16(*((u16 *)&eth->h_source[4]));
 		entry.ipv6_5t_route.pppoe_id = hw_path->pppoe_sid;
+		/*entry.ipv6_5t_route.pppoe_id = (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) ?
+						hw_path->encap.id : 0;*/
 		break;
 	}
 	return entry;
 }
 
 struct foe_entry ppe_fill_info_blk(struct ethhdr *eth, struct foe_entry entry,
-				   struct flow_offload_hw_path *hw_path)
+				   struct hnat_hw_path *hw_path)
+				   //struct flow_offload_hw_path *hw_path)
 {
-	entry.bfib1.psn = (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) ? 1 : 0;
-	entry.bfib1.vlan_layer += (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ? 1 : 0;
+	entry.bfib1.psn = (hw_path->flags & HNAT_PATH_PPPOE) ? 1 : 0;
+	entry.bfib1.vlan_layer += (hw_path->flags & HNAT_PATH_VLAN) ? 1 : 0;
+	/*entry.bfib1.psn = (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE) ? 1 : 0;
+	entry.bfib1.vlan_layer += (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ? 1 : 0;*/
 	entry.bfib1.vpm = (entry.bfib1.vlan_layer) ? 1 : 0;
+	//FIXME:entry.bfib1.ttl = 1;
 	entry.bfib1.cah = 1;
+	//FIXME:entry.bfib1.ka = 1;
 	entry.bfib1.time_stamp = (hnat_priv->data->version == MTK_HNAT_V2 ||
 				  hnat_priv->data->version == MTK_HNAT_V3) ?
 		readl(hnat_priv->fe_base + 0x0010) & (0xFF) :
@@ -1135,6 +1246,7 @@ struct foe_entry ppe_fill_info_blk(struct ethhdr *eth, struct foe_entry entry,
 	switch ((int)entry.bfib1.pkt_type) {
 	case IPV4_HNAPT:
 	case IPV4_HNAT:
+		//if (is_multicast_ether_addr(&eth->h_dest[0])) {
 		if (hnat_priv->data->mcast &&
 		    is_multicast_ether_addr(&eth->h_dest[0])) {
 			entry.ipv4_hnapt.iblk2.mcast = 1;
@@ -1157,6 +1269,7 @@ struct foe_entry ppe_fill_info_blk(struct ethhdr *eth, struct foe_entry entry,
 	case IPV6_3T_ROUTE:
 	case IPV6_HNAPT:
 	case IPV6_HNAT:
+		//if (is_multicast_ether_addr(&eth->h_dest[0])) {
 		if (hnat_priv->data->mcast &&
 		    is_multicast_ether_addr(&eth->h_dest[0])) {
 			entry.ipv6_5t_route.iblk2.mcast = 1;
@@ -1177,12 +1290,14 @@ struct foe_entry ppe_fill_info_blk(struct ethhdr *eth, struct foe_entry entry,
 }
 
 static struct ethhdr *get_ipv6_ipip_ethhdr(struct sk_buff *skb,
-					   struct flow_offload_hw_path *hw_path)
+					   struct hnat_hw_path *hw_path)
+					   //struct flow_offload_hw_path *hw_path)
 {
 	struct ethhdr *eth;
 	u16 eth_pppoe_hlen = ETH_HLEN + PPPOE_SES_HLEN;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE)
+	if (hw_path->flags & HNAT_PATH_PPPOE)
+	//if (hw_path->flags & FLOW_OFFLOAD_PATH_PPPOE)
 		eth = (struct ethhdr *)(skb->data - eth_pppoe_hlen);
 	else
 		eth = (struct ethhdr *)(skb->data - ETH_HLEN);
@@ -1193,7 +1308,8 @@ static struct ethhdr *get_ipv6_ipip_ethhdr(struct sk_buff *skb,
 static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				     const struct net_device *dev,
 				     struct foe_entry *foe,
-				     struct flow_offload_hw_path *hw_path)
+				     struct hnat_hw_path *hw_path)
+				     //struct flow_offload_hw_path *hw_path)
 {
 	struct foe_entry entry = { 0 };
 	int whnat = IS_WHNAT(dev);
@@ -1210,6 +1326,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 	u32 port_id = 0;
 	int mape = 0;
 
+	//FIXME:
 	ct = nf_ct_get(skb, &ctinfo);
 
 	if (ipv6_hdr(skb)->nexthdr == NEXTHDR_IPIP)
@@ -1218,11 +1335,17 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 	else
 		eth = eth_hdr(skb);
 
+	//if (is_multicast_ether_addr(eth->h_dest)) {
+	//	/*do not bind multicast if PPE mcast not enable*/
+	//	if (!hnat_priv->pmcast)
+	//		return 0;
+	//}
 	/*do not bind multicast if PPE mcast not enable*/
 	if (!hnat_priv->data->mcast && is_multicast_ether_addr(eth->h_dest))
 		return 0;
 
 	entry.bfib1.pkt_type = foe->udib1.pkt_type; /* Get packte type state*/
+	//FIXME:
 	entry.bfib1.state = foe->udib1.state;
 
 #if defined(CONFIG_MEDIATEK_NETSYS_V2) || defined(CONFIG_MEDIATEK_NETSYS_V3)
@@ -1290,6 +1413,9 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				entry.ipv4_dslite.bfib1.rmt = 1;
 				entry.ipv4_dslite.iblk2.dscp = iph->tos;
 				entry.ipv4_dslite.vlan1 = hw_path->vlan_id;
+				/*entry.ipv4_dslite.vlan1 =
+					(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+					 hw_path->encap.id : 0;*/
 				if (hnat_priv->data->per_flow_accounting)
 					entry.ipv4_dslite.iblk2.mibf = 1;
 
@@ -1299,7 +1425,18 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 					entry.ipv4_hnapt.iblk2.mibf = 1;
 
 				entry.ipv4_hnapt.vlan1 = hw_path->vlan_id;
+				/*entry.ipv4_hnapt.vlan1 =
+					(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+					 hw_path->encap.id : 0;*/
 
+				/*if (skb->vlan_tci && FROM_GE_WAN(skb) && IS_LAN(dev)) {
+					entry.bfib1.vlan_layer += 1;
+
+					if (entry.ipv4_hnapt.vlan1)
+						entry.ipv4_hnapt.vlan2 = (skb->vlan_tci & VLAN_VID_MASK);
+					else
+						entry.ipv4_hnapt.vlan1 = (skb->vlan_tci & VLAN_VID_MASK);
+				}*/
 				if (skb_vlan_tag_present(skb)) {
 					entry.bfib1.vlan_layer += 1;
 
@@ -1353,7 +1490,18 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 			entry.ipv6_5t_route.etype = htons(ETH_P_IPV6);
 
 			entry.ipv6_5t_route.vlan1 = hw_path->vlan_id;
+			/*entry.ipv6_5t_route.vlan1 =
+				(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+				 hw_path->encap.id : 0;*/
+
+			/*if (skb->vlan_tci && FROM_GE_WAN(skb) && IS_LAN(dev)) {
+				entry.bfib1.vlan_layer += 1;
 
+				if (entry.ipv6_5t_route.vlan1)
+					entry.ipv6_5t_route.vlan2 = (skb->vlan_tci & VLAN_VID_MASK);
+				else
+					entry.ipv6_5t_route.vlan1 = (skb->vlan_tci & VLAN_VID_MASK);
+			}*/
 			if (skb_vlan_tag_present(skb)) {
 				entry.bfib1.vlan_layer += 1;
 
@@ -1466,6 +1614,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 			    (mape_toggle &&
 			     entry.bfib1.pkt_type == IPV4_MAP_E)) {
 				/* DS-Lite LAN->WAN */
+				//FIXME:
 				entry.ipv4_dslite.bfib1.udp =
 					foe->ipv4_dslite.bfib1.udp;
 				entry.ipv4_dslite.sip = foe->ipv4_dslite.sip;
@@ -1498,6 +1647,9 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				entry.ipv4_dslite.priority = ip6h->priority;
 				entry.ipv4_dslite.hop_limit = ip6h->hop_limit;
 				entry.ipv4_dslite.vlan1 = hw_path->vlan_id;
+				/*entry.ipv4_dslite.vlan1 =
+					(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+					 hw_path->encap.id : 0;*/
 				if (hnat_priv->data->per_flow_accounting)
 					entry.ipv4_dslite.iblk2.mibf = 1;
 				/* Map-E LAN->WAN record inner IPv4 header info. */
@@ -1519,10 +1671,14 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				if (hnat_priv->data->per_flow_accounting)
 					entry.ipv4_hnapt.iblk2.mibf = 1;
 
+				//FIXME:
 				if (IS_GMAC1_MODE)
 					entry.ipv4_hnapt.vlan1 = 1;
 				else
 					entry.ipv4_hnapt.vlan1 = hw_path->vlan_id;
+					/*entry.ipv4_hnapt.vlan1 =
+						(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+						 hw_path->encap.id : 0;*/
 
 				entry.ipv4_hnapt.sip = foe->ipv4_hnapt.sip;
 				entry.ipv4_hnapt.dip = foe->ipv4_hnapt.dip;
@@ -1535,6 +1691,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 					foe->ipv4_hnapt.new_dip;
 				entry.ipv4_hnapt.etype = htons(ETH_P_IP);
 
+				//if (qos_toggle) {
 				if (IS_HQOS_MODE) {
 					entry.ipv4_hnapt.iblk2.qid =
 						(hnat_priv->data->version ==
@@ -1578,6 +1735,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 		break;
 
 	default:
+		//FIXME:ip6h = ipv6_hdr(skb);
 		iph = ip_hdr(skb);
 		switch (entry.bfib1.pkt_type) {
 		case IPV6_6RD: /* 6RD LAN->WAN */
@@ -1601,6 +1759,9 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 			entry.ipv6_6rd.dscp = iph->tos;
 			entry.ipv6_6rd.per_flow_6rd_id = 1;
 			entry.ipv6_6rd.vlan1 = hw_path->vlan_id;
+			/*entry.ipv6_6rd.vlan1 =
+				(hw_path->flags & FLOW_OFFLOAD_PATH_VLAN) ?
+				 hw_path->encap.id : 0;*/
 			if (hnat_priv->data->per_flow_accounting)
 				entry.ipv6_6rd.iblk2.mibf = 1;
 			break;
@@ -1625,8 +1786,12 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 		if (IS_BOND_MODE)
 			gmac = ((skb_hnat_entry(skb) >> 1) % hnat_priv->gmac_num) ?
 				 NR_GMAC2_PORT : NR_GMAC1_PORT;
-		else
-			gmac = NR_GMAC1_PORT;
+		else {
+			if (of_machine_is_compatible("glinet,gl-mt3000")||of_machine_is_compatible("glinet,mt3000-snand"))
+				gmac = NR_GMAC2_PORT;
+			else
+				gmac = NR_GMAC1_PORT;
+		}
 	} else if (IS_LAN2(dev)) {
 		gmac = NR_GMAC3_PORT;
 	} else if (IS_WAN(dev)) {
@@ -1639,8 +1804,13 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 			/* Set act_dp = wan_dev */
 			entry.ipv4_hnapt.act_dp = dev->ifindex;
 		} else {
-			gmac = (IS_GMAC1_MODE) ? NR_GMAC1_PORT : NR_GMAC2_PORT;
+			if (of_machine_is_compatible("glinet,gl-mt3000")||of_machine_is_compatible("glinet,mt3000-snand"))
+				gmac = NR_GMAC1_PORT;
+			else
+				gmac = (IS_GMAC1_MODE) ? NR_GMAC1_PORT : NR_GMAC2_PORT;
 		}
+	/*FIXME:} else if (IS_EXT(dev)) {
+		if ((hnat_priv->data->version != MTK_HNAT_V2) && IS_GMAC1_MODE) {*/
 	} else if (IS_EXT(dev) && (FROM_GE_PPD(skb) || FROM_GE_LAN_GRP(skb) ||
 		   FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb) || FROM_WED(skb))) {
 		if (!hnat_priv->data->whnat && IS_GMAC1_MODE) {
@@ -1671,8 +1841,10 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 		return 0;
 	}
 
+	//if (IS_HQOS_MODE)
 	if (IS_HQOS_MODE || skb->mark >= MAX_PPPQ_PORT_NUM)
 		qid = skb->mark & (MTK_QDMA_TX_MASK);
+	//else if (IS_PPPQ_MODE)
 	else if (IS_PPPQ_MODE && IS_PPPQ_PATH(dev, skb))
 		qid = port_id & MTK_QDMA_TX_MASK;
 	else
@@ -1704,6 +1876,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				}
 			}
 
+			//if (FROM_EXT(skb) || skb_hnat_sport(skb) == NR_QDMA_PORT)
 			if (FROM_EXT(skb) || skb_hnat_sport(skb) == NR_QDMA_PORT ||
 			    (IS_PPPQ_MODE && !IS_DSA_LAN(dev) && !IS_DSA_WAN(dev)))
 				entry.ipv4_hnapt.iblk2.fqos = 0;
@@ -1750,6 +1923,7 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 				}
 			}
 
+			//if (FROM_EXT(skb))
 			if (FROM_EXT(skb) ||
 			    (IS_PPPQ_MODE && !IS_DSA_LAN(dev) && !IS_DSA_WAN(dev)))
 				entry.ipv6_5t_route.iblk2.fqos = 0;
@@ -1778,10 +1952,12 @@ static unsigned int skb_to_hnat_info(struct sk_buff *skb,
 	 * the entry is set to BIND state in mtk_sw_nat_hook_tx().
 	 */
 	if (!whnat) {
+		//FIXME:
 		entry.bfib1.ttl = 1;
 		entry.bfib1.state = BIND;
 	}
 
+	//FIXME:
 	wmb();
 	memcpy(foe, &entry, sizeof(entry));
 	/*reset statistic for this entry*/
@@ -1802,6 +1978,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 	struct ethhdr *eth;
 	struct hnat_bind_info_blk bfib1_tx;
 
+	//FIXME:if (skb_hnat_alg(skb) || !is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb))
 	if (skb_hnat_alg(skb) || !is_hnat_info_filled(skb) ||
 	    !is_magic_tag_valid(skb) || !IS_SPACE_AVAILABLE_HEAD(skb))
 		return NF_ACCEPT;
@@ -1812,6 +1989,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 		skb_hnat_wdma_id(skb), skb_hnat_bss_id(skb),
 		skb_hnat_wc_id(skb), skb_hnat_rx_id(skb));
 
+	//FIXME:
 	if ((gmac_no != NR_WDMA0_PORT) && (gmac_no != NR_WDMA1_PORT) &&
 	    (gmac_no != NR_WHNAT_WDMA_PORT))
 		return NF_ACCEPT;
@@ -1834,8 +2012,14 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 		return NF_ACCEPT;
 
 	eth = eth_hdr(skb);
+	//FIXME:
 	memcpy(&bfib1_tx, &entry->bfib1, sizeof(entry->bfib1));
 
+	//if (is_multicast_ether_addr(eth->h_dest)) {
+	//	/*not bind multicast if PPE mcast not enable*/
+	//	if (!hnat_priv->pmcast)
+	//		return NF_ACCEPT;
+	//}
 	/*not bind multicast if PPE mcast not enable*/
 	if (!hnat_priv->data->mcast) {
 		if (is_multicast_ether_addr(eth->h_dest))
@@ -1873,9 +2057,17 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 		bfib1_tx.vpm = 1;
 		if (IS_IPV4_GRP(entry)) {
 			entry->ipv4_hnapt.etype = htons(ETH_P_8021Q);
+			/*FIXME:if(entry->ipv4_hnapt.vlan1)
+				entry->ipv4_hnapt.vlan2 = skb->vlan_tci;
+			else
+				entry->ipv4_hnapt.vlan1 = skb->vlan_tci;*/
 			entry->ipv4_hnapt.vlan1 = skb->vlan_tci;
 		} else if (IS_IPV6_GRP(entry)) {
 			entry->ipv6_5t_route.etype = htons(ETH_P_8021Q);
+			/*FIXME:if(entry->ipv6_5t_route.vlan1)
+				entry->ipv6_5t_route.vlan2 = skb->vlan_tci;
+			else
+				entry->ipv6_5t_route.vlan1 = skb->vlan_tci;*/
 			entry->ipv6_5t_route.vlan1 = skb->vlan_tci;
 		}
 	} else {
@@ -1894,6 +2086,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 			entry->ipv4_hnapt.winfo.bssid = skb_hnat_bss_id(skb);
 			entry->ipv4_hnapt.winfo.wcid = skb_hnat_wc_id(skb);
 #if defined(CONFIG_MEDIATEK_NETSYS_V3)
+			//entry->ipv4_hnapt.iblk2.fqos = (qos_toggle) ? 1 : 0;
 			entry->ipv4_hnapt.tport_id = IS_HQOS_DL_MODE ? 1 : 0;
 			entry->ipv4_hnapt.iblk2.rxid = skb_hnat_rx_id(skb);
 			entry->ipv4_hnapt.iblk2.winfoi = 1;
@@ -1908,6 +2101,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 			entry->ipv4_hnapt.winfo_pao.hf = skb_hnat_hf(skb);
 			entry->ipv4_hnapt.winfo_pao.amsdu = skb_hnat_amsdu(skb);
 #elif defined(CONFIG_MEDIATEK_NETSYS_V2)
+			//entry->ipv4_hnapt.iblk2.fqos = (qos_toggle) ? 1 : 0;
 			entry->ipv4_hnapt.iblk2.rxid = skb_hnat_rx_id(skb);
 			entry->ipv4_hnapt.iblk2.winfoi = 1;
 #else
@@ -1926,6 +2120,8 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 					entry->ipv4_hnapt.vlan1 = 2;
 			}
 
+			/*if (qos_toggle &&
+			    (FROM_GE_LAN_GRP(skb) || FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {*/
 			if (IS_HQOS_MODE &&
 			    (FROM_GE_LAN_GRP(skb) || FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {
 				bfib1_tx.vpm = 0;
@@ -1964,6 +2160,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 			entry->ipv6_5t_route.winfo.bssid = skb_hnat_bss_id(skb);
 			entry->ipv6_5t_route.winfo.wcid = skb_hnat_wc_id(skb);
 #if defined(CONFIG_MEDIATEK_NETSYS_V3)
+			//entry->ipv6_5t_route.iblk2.fqos = (qos_toggle) ? 1 : 0;
 			entry->ipv6_5t_route.tport_id = IS_HQOS_DL_MODE ? 1 : 0;
 			entry->ipv6_5t_route.iblk2.rxid = skb_hnat_rx_id(skb);
 			entry->ipv6_5t_route.iblk2.winfoi = 1;
@@ -1982,6 +2179,7 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 			entry->ipv6_5t_route.winfo_pao.amsdu =
 				skb_hnat_amsdu(skb);
 #elif defined(CONFIG_MEDIATEK_NETSYS_V2)
+			//entry->ipv6_5t_route.iblk2.fqos = (qos_toggle) ? 1 : 0;
 			entry->ipv6_5t_route.iblk2.rxid = skb_hnat_rx_id(skb);
 			entry->ipv6_5t_route.iblk2.winfoi = 1;
 #else
@@ -2000,6 +2198,8 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 					entry->ipv6_5t_route.vlan1 = 2;
 			}
 
+			/*if (qos_toggle &&
+			    (FROM_GE_LAN_GRP(skb) || FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {*/
 			if (IS_HQOS_MODE &&
 			    (FROM_GE_LAN_GRP(skb) || FROM_GE_WAN(skb) || FROM_GE_VIRTUAL(skb))) {
 				bfib1_tx.vpm = 0;
@@ -2012,8 +2212,10 @@ int mtk_sw_nat_hook_tx(struct sk_buff *skb, int gmac_no)
 		entry->ipv6_5t_route.iblk2.dp = gmac_no;
 	}
 
+	//FIXME:
 	bfib1_tx.ttl = 1;
 	bfib1_tx.state = BIND;
+	//FIXME:
 	wmb();
 	memcpy(&entry->bfib1, &bfib1_tx, sizeof(bfib1_tx));
 
@@ -2044,6 +2246,14 @@ void mtk_ppe_dev_register_hook(struct net_device *dev)
 	int i, number = 0;
 	struct extdev_entry *ext_entry;
 
+	/*FIXME:if (dev->name && !strcmp(dev->name, "wds"))
+		return;*/
+
+	/*TODO:if (!hnat_priv->guest_en && dev->name) {
+		if (!strcmp(dev->name, "ra1") || !strcmp(dev->name, "rai1") || !strcmp(dev->name, "rax1"))
+			return;
+	}*/
+
 	for (i = 1; i < MAX_IF_NUM; i++) {
 		if (hnat_priv->wifi_hook_if[i] == dev) {
 			pr_info("%s : %s has been registered in wifi_hook_if table[%d]\n",
@@ -2139,11 +2349,15 @@ static void mtk_hnat_dscp_update(struct sk_buff *skb, struct foe_entry *entry)
 	switch (ntohs(eth->h_proto)) {
 	case ETH_P_IP:
 		iph = ip_hdr(skb);
+		//if (entry->ipv4_hnapt.iblk2.dscp != iph->tos)
 		if (IS_IPV4_GRP(entry) && entry->ipv4_hnapt.iblk2.dscp != iph->tos)
 			flag = true;
 		break;
 	case ETH_P_IPV6:
 		ip6h = ipv6_hdr(skb);
+		/*if (entry->ipv6_5t_route.iblk2.dscp !=
+			(ip6h->priority << 4 |
+			 (ip6h->flow_lbl[0] >> 4)))*/
 		if ((IS_IPV6_3T_ROUTE(entry) || IS_IPV6_5T_ROUTE(entry)) &&
 			(entry->ipv6_5t_route.iblk2.dscp !=
 			(ip6h->priority << 4 | (ip6h->flow_lbl[0] >> 4))))
@@ -2468,14 +2682,20 @@ int mtk_464xlat_post_process(struct sk_buff *skb, const struct net_device *out)
 static unsigned int mtk_hnat_nf_post_routing(
 	struct sk_buff *skb, const struct net_device *out,
 	unsigned int (*fn)(struct sk_buff *, const struct net_device *,
-			   struct flow_offload_hw_path *),
+			   struct hnat_hw_path *),
+			   //struct flow_offload_hw_path *),
 	const char *func)
 {
 	struct foe_entry *entry;
-	struct flow_offload_hw_path hw_path = { .dev = (struct net_device*)out,
-						.virt_dev = (struct net_device*)out };
+	struct hnat_hw_path hw_path = { .real_dev = out, .virt_dev = out };
+	/*struct flow_offload_hw_path hw_path = { .dev = (struct net_device*)out,
+						.virt_dev = (struct net_device*)out };*/
 	const struct net_device *arp_dev = out;
 
+	/*TODO:if (skb->protocol == htons(ETH_P_IPV6) && !hnat_priv->ipv6_en) {
+		return 0;
+	}*/
+
 	if (xlat_toggle && !mtk_464xlat_post_process(skb, out))
 		return 0;
 
@@ -2483,6 +2703,7 @@ static unsigned int mtk_hnat_nf_post_routing(
 					  !IS_SPACE_AVAILABLE_HEAD(skb)))
 		return 0;
 
+	//FIXME:
 	if (unlikely(!skb_mac_header_was_set(skb)))
 		return 0;
 
@@ -2493,9 +2714,13 @@ static unsigned int mtk_hnat_nf_post_routing(
 	if (ip_is_fragment(ip_hdr(skb)))
 		return 0;
 
-	if (out->netdev_ops->ndo_flow_offload_check) {
+	if (out->netdev_ops->ndo_hnat_check) {
+		if (out->netdev_ops->ndo_hnat_check(&hw_path))
+			return 0;
+		out = (IS_GMAC1_MODE) ? hw_path.virt_dev : hw_path.real_dev;
+	/*if (out->netdev_ops->ndo_flow_offload_check) {
 		out->netdev_ops->ndo_flow_offload_check(&hw_path);
-		out = (IS_GMAC1_MODE) ? hw_path.virt_dev : hw_path.dev;
+		out = (IS_GMAC1_MODE) ? hw_path.virt_dev : hw_path.dev;*/
 	}
 
 	if (!IS_LAN_GRP(out) && !IS_WAN(out) && !IS_EXT(out))
@@ -2524,6 +2749,7 @@ static unsigned int mtk_hnat_nf_post_routing(
 		skb_to_hnat_info(skb, out, entry, &hw_path);
 		break;
 	case HIT_BIND_KEEPALIVE_DUP_OLD_HDR:
+		//FIXME:
 		/* update hnat count to nf_conntrack by keepalive */
 		if (hnat_priv->data->per_flow_accounting && hnat_priv->nf_stat_en)
 			mtk_hnat_nf_update(skb);
@@ -2531,6 +2757,7 @@ static unsigned int mtk_hnat_nf_post_routing(
 		if (fn && !mtk_hnat_accel_type(skb))
 			break;
 
+		//FIXME:
 		/* update dscp for qos */
 		mtk_hnat_dscp_update(skb, entry);
 
@@ -2540,6 +2767,7 @@ static unsigned int mtk_hnat_nf_post_routing(
 			entry->ipv4_hnapt.m_timestamp = foe_timestamp(hnat_priv);
 
 		if (entry_hnat_is_bound(entry)) {
+			//FIXME:memset(skb_hnat_info(skb), 0, FOE_INFO_LEN);
 			memset(skb_hnat_info(skb), 0, sizeof(struct hnat_desc));
 
 			return -1;
@@ -2692,6 +2920,7 @@ mtk_pong_hqos_handler(void *priv, struct sk_buff *skb,
 
 	veth = (struct vlan_ethhdr *)skb_mac_header(skb);
 
+	//if (qos_toggle && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 	if (IS_HQOS_MODE && eth_hdr(skb)->h_proto == HQOS_MAGIC_TAG) {
 		skb_hnat_entry(skb) = ntohs(veth->h_vlan_TCI) & 0x3fff;
 		skb_hnat_reason(skb) = HIT_BIND_FORCE_TO_CPU;
@@ -2798,6 +3027,7 @@ static unsigned int mtk_hnat_br_nf_forward(void *priv,
 					   struct sk_buff *skb,
 					   const struct nf_hook_state *state)
 {
+	//FIXME:if (unlikely(IS_EXT(state->in) && IS_EXT(state->out)))
 	if ((hnat_priv->data->version == MTK_HNAT_V1_2) &&
 	    unlikely(IS_EXT(state->in) && IS_EXT(state->out)))
 		hnat_set_head_frags(state, skb, 1, hnat_set_alg);
@@ -2845,12 +3075,14 @@ static struct nf_hook_ops mtk_hnat_nf_ops[] __read_mostly = {
 	{
 		.hook = mtk_hnat_br_nf_local_in,
 		.pf = NFPROTO_BRIDGE,
+		//FIXME:.hooknum = NF_BR_PRE_ROUTING,
 		.hooknum = NF_BR_LOCAL_IN,
 		.priority = NF_BR_PRI_FIRST,
 	},
 	{
 		.hook = mtk_hnat_br_nf_local_out,
 		.pf = NFPROTO_BRIDGE,
+		//FIXME:.hooknum = NF_BR_POST_ROUTING,
 		.hooknum = NF_BR_LOCAL_OUT,
 		.priority = NF_BR_PRI_LAST - 1,
 	},
@@ -2864,11 +3096,13 @@ static struct nf_hook_ops mtk_hnat_nf_ops[] __read_mostly = {
 
 int hnat_register_nf_hooks(void)
 {
+	//FIXME:return nf_register_hooks(mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
 	return nf_register_net_hooks(&init_net, mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
 }
 
 void hnat_unregister_nf_hooks(void)
 {
+	//FIXME:nf_unregister_hooks(mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
 	nf_unregister_net_hooks(&init_net, mtk_hnat_nf_ops, ARRAY_SIZE(mtk_hnat_nf_ops));
 }
 
@@ -2880,6 +3114,7 @@ int whnat_adjust_nf_hooks(void)
 	while (n-- > 0) {
 		if (hook[n].hook == mtk_hnat_br_nf_local_in) {
 			hook[n].hooknum = NF_BR_PRE_ROUTING;
+			//FIXME:
 			hook[n].priority = NF_BR_PRI_FIRST + 1;
 		} else if (hook[n].hook == mtk_hnat_br_nf_local_out) {
 			hook[n].hooknum = NF_BR_POST_ROUTING;
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_stag.c b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_stag.c
index 75c3a75c..3ef8075e 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_stag.c
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/hnat_stag.c
@@ -4,13 +4,14 @@
  * Author: Landen Chao <landen.chao@mediatek.com>
  */
 
-#include <linux/of_device.h>
-#include <net/netfilter/nf_flow_table.h>
+//#include <linux/of_device.h>
+//#include <net/netfilter/nf_flow_table.h>
 #include "hnat.h"
 
 u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 		       struct foe_entry *entry,
-		       struct flow_offload_hw_path *hw_path,
+		       struct hnat_hw_path *hw_path,
+		       //struct flow_offload_hw_path *hw_path,
 		       u16 eth_proto,
 		       int mape)
 {
@@ -19,8 +20,10 @@ u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 	int port_index;
 	u16 sp_tag;
 
-	if (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN)
-		ndev = hw_path->dev;
+	if (hw_path->flags & HNAT_PATH_VLAN)
+		ndev = hw_path->real_dev;
+	/*if (hw_path->flags & FLOW_OFFLOAD_PATH_VLAN)
+		ndev = hw_path->dev;*/
 	else
 		ndev = netdev;
 
@@ -40,6 +43,7 @@ u32 hnat_dsa_fill_stag(const struct net_device *netdev,
 
 	switch (eth_proto) {
 	case ETH_P_IP:
+		//FIXME:if (entry->ipv4_hnapt.bfib1.pkt_type == IPV4_DSLITE)
 		if (entry->ipv4_hnapt.bfib1.pkt_type == IPV4_DSLITE
 			|| (entry->ipv4_hnapt.bfib1.pkt_type == IPV4_MAP_E))
 			entry->ipv4_dslite.etype = sp_tag;
diff --git a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/nf_hnat_mtk.h b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/nf_hnat_mtk.h
index d9eba8dc..6bb66858 100644
--- a/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/nf_hnat_mtk.h
+++ b/trunk/linux-4.4.x/drivers/net/ethernet/raeth/mtk_hnat/nf_hnat_mtk.h
@@ -16,7 +16,7 @@
 
 #include <linux/dma-mapping.h>
 #include <linux/netdevice.h>
-#include "../mtk_eth_soc.h"
+//#include "../mtk_eth_soc.h"
 
 #define HNAT_SKB_CB2(__skb) ((struct hnat_skb_cb2 *)&((__skb)->cb[44]))
 struct hnat_skb_cb2 {
@@ -68,14 +68,19 @@ struct hnat_desc {
 struct hnat_desc {
 	u32 entry : 14;
 	u32 crsn : 5;
+	/*u32 sport : 3;
+	u32 rev : 1;*/
 	u32 sport : 4;
 	u32 alg : 1;
+	//FIXME:u32 iface : 4;
 	u32 iface : 8;
+	//u32 resv : 4;
 	u32 filled : 3;
 	u32 resv : 1;
 	u32 magic_tag_protect : 16;
 	u32 wdmaid : 8;
 	u32 rxid : 2;
+	//FIXME:u32 wcid : 8;
 	u32 wcid : 10;
 	u32 bssid : 6;
 } __packed;
@@ -86,6 +91,7 @@ struct hnat_desc {
 
 #define HNAT_MAGIC_TAG 0x6789
 #define HNAT_INFO_FILLED 0x7
+//FIXME:#define WIFI_INFO_LEN 3
 #define WIFI_INFO_LEN 6
 #define FOE_INFO_LEN (10 + WIFI_INFO_LEN)
 #define IS_SPACE_AVAILABLE_HEAD(skb)                                           \
-- 
2.32.0.windows.2

